<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Memory</name>
  </assembly>
  <members>
    <member name="T:System.Buffers.ArrayBufferWriter`1">
      <summary>データを書き込むことができる、ヒープベースの <typeparam name="T" /> 配列に裏付けられた出力シンクを表します。</summary>
      <typeparam name="T">このインスタンス内の項目の型 <see cref="T:System.Buffers.ArrayBufferWriter`1" /> 。</typeparam>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
      <summary>データを書き込むことができる、既定の初期容量を備えた <see cref="T:System.Buffers.ArrayBufferWriter`1" /> のインスタンスを作成します。</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
      <summary>データを書き込むことができる、指定した初期容量を備えた <see cref="T:System.Buffers.ArrayBufferWriter`1" /> のインスタンスを作成します。</summary>
      <param name="initialCapacity">基になるバッファーの初期化に使用する最小容量。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCapacity" /> が 0 以下です。</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
      <summary>
        <paramref name="count" /> 項目が出力 <see cref="T:System.Span`1" />/<see cref="T:System.Memory`1" /> に書き込まれたことを <see cref="T:System.Buffers.IBufferWriter`1" /> に通知します</summary>
      <param name="count">書き込まれる項目の数。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="count" /> が負の値です。</exception>
      <exception cref="T:System.InvalidOperationException">メソッドの呼び出しで、基になるバッファーの末尾を超えて前進することを試みます。</exception>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
      <summary>基になるバッファーに書き込まれたデータを消去します。</summary>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
      <summary>少なくとも <paramref name="sizeHint" /> で指定された長さがある、書き込み先となる <see cref="T:System.Memory`1" /> を返します。</summary>
      <param name="sizeHint">
        <see cref="T:System.Memory`1" /> の要求される最小の長さ。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> が負の値です。</exception>
      <returns>長さが少なくとも <paramref name="sizeHint" /> の <see cref="T:System.Memory`1" />。  <paramref name="sizeHint" /> が指定されていないか、0 の場合、空でないバッファーがいくつか返されます。</returns>
    </member>
    <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
      <summary>指定された長さ以上の書き込み先となる <see cref="T:System.Span`1" /> を返します。</summary>
      <param name="sizeHint">
        <see cref="T:System.Span`1" /> の要求される最小の長さ。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="sizeHint" /> が負の値です。</exception>
      <returns>長さが少なくとも <paramref name="sizeHint" /> のスパン。 <paramref name="sizeHint" /> が指定されていないか、0 の場合、空でないバッファーがいくつか返されます。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
      <summary>基になるバッファー内の領域の合計量を取得します。</summary>
      <returns>基になるバッファーの合計容量。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
      <summary>基になるバッファーの拡大を強制せずに書き込むことができる使用可能な領域の量を取得します。</summary>
      <returns>基になるバッファーを強制的に拡張せずに、書き込みに使用できる領域。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
      <summary>基になるバッファーに書き込まれたデータの量を取得します。</summary>
      <returns>基になるバッファーに書き込まれたデータの量。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
      <summary>基になるバッファーにこれまで書き込まれたデータが格納されている <see cref="T:System.ReadOnlyMemory`1" /> を取得します。</summary>
      <returns>基になるバッファーに書き込まれたデータ。</returns>
    </member>
    <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
      <summary>基になるバッファーにこれまで書き込まれたデータが格納されている <see cref="T:System.ReadOnlySpan`1" /> を取得します。</summary>
      <returns>基になるバッファーに書き込まれたデータ。</returns>
    </member>
    <member name="T:System.Buffers.Binary.BinaryPrimitives">
      <summary>特定のエンディアンを持つプリミティブとしてバイトを読み取ります。</summary>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Double" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Double" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Double" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Double" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Int16" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Int16" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Int16" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Int16" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Int32" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Int32" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Int32" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Int32" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Int64" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Int64" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Int64" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Int64" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Single" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Single" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Single" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.Single" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.UInt16" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.UInt16" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.UInt16" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.UInt16" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.UInt32" /> を読み取ります。</summary>
      <param name="source">読み取る読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.UInt32" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.UInt32" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.UInt32" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.UInt64" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.UInt64" /> を格納できません。</exception>
      <returns>ビッグ エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.UInt64" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が小さすぎて <see cref="T:System.UInt64" /> を格納できません。</exception>
      <returns>リトル エンディアン値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
      <summary>指定された <see cref="T:System.Byte" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。<see cref="T:System.Byte" /> に対しては、実質的には何も行われません。</summary>
      <param name="value">反転する値。</param>
      <returns>渡された値 (変更されていない)。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
      <summary>指定された <see cref="T:System.Int16" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。</summary>
      <param name="value">反転する値。</param>
      <returns>反転された値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
      <summary>指定された <see cref="T:System.Int32" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。</summary>
      <param name="value">反転する値。</param>
      <returns>反転された値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
      <summary>指定された <see cref="T:System.Int64" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。</summary>
      <param name="value">反転する値。</param>
      <returns>反転された値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
      <summary>指定された <see cref="T:System.SByte" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。<see cref="T:System.SByte" /> に対しては、実質的には何も行われません。</summary>
      <param name="value">反転する値。</param>
      <returns>渡された値 (変更されていない)。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
      <summary>指定された <see cref="T:System.UInt16" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。</summary>
      <param name="value">反転する値。</param>
      <returns>反転された値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
      <summary>指定された <see cref="T:System.UInt32" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。</summary>
      <param name="value">反転する値。</param>
      <returns>反転された値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
      <summary>指定された <see cref="T:System.UInt64" /> 値のエンディアン スワップを実行して、プリミティブ値を反転します。</summary>
      <param name="value">反転する値。</param>
      <returns>反転された値。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Double" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから戻った時点では、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られた値が格納されています。</param>
      <returns>スパンが <see cref="T:System.Double" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Double" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから戻った時点では、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られた値が格納されています。</param>
      <returns>スパンが <see cref="T:System.Double" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Int16" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.Int16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Int16" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.Int16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Int32" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.Int32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Int32" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.Int32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Int64" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.Int64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Int64" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.Int64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.Single" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから戻った時点では、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られた値が格納されています。</param>
      <returns>スパンが <see cref="T:System.Single" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.Single" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから戻った時点では、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られた値が格納されています。</param>
      <returns>スパンが <see cref="T:System.Single" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.UInt16" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.UInt16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.UInt16" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.UInt16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.UInt32" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.UInt32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.UInt32" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.UInt32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>バイトの読み取り専用スパンの先頭から、ビッグ エンディアンとして <see cref="T:System.UInt64" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、ビッグ エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.UInt64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
      <summary>バイトの読み取り専用スパンの先頭から、リトル エンディアンとして <see cref="T:System.UInt64" /> を読み取ります。</summary>
      <param name="source">読み取るバイトの読み取り専用スパン。</param>
      <param name="value">このメソッドから制御が戻るときに、バイトの読み取り専用スパンから、リトル エンディアンとして読み取られる値。</param>
      <returns>スパンが <see cref="T:System.UInt64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>
        <see cref="T:System.Double" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Double" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>
        <see cref="T:System.Double" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Double" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>
        <see cref="T:System.Int16" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Int16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>
        <see cref="T:System.Int16" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Int16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>
        <see cref="T:System.Int32" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Int32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>
        <see cref="T:System.Int32" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Int32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>
        <see cref="T:System.Int64" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Int64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>
        <see cref="T:System.Int64" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Int64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>
        <see cref="T:System.Single" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Single" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>
        <see cref="T:System.Single" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.Single" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>
        <see cref="T:System.UInt16" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.UInt16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>
        <see cref="T:System.UInt16" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.UInt16" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>
        <see cref="T:System.UInt32" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.UInt32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>
        <see cref="T:System.UInt32" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.UInt32" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>
        <see cref="T:System.UInt64" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.UInt64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>
        <see cref="T:System.UInt64" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <returns>スパンが <see cref="T:System.UInt64" /> を格納するのに十分な大きさである場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)">
      <summary>
        <see cref="T:System.Double" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Double" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)">
      <summary>
        <see cref="T:System.Double" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Double" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
      <summary>
        <see cref="T:System.Int16" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Int16" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
      <summary>
        <see cref="T:System.Int16" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Int16" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
      <summary>
        <see cref="T:System.Int32" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Int32" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
      <summary>
        <see cref="T:System.Int32" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Int32" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
      <summary>
        <see cref="T:System.Int64" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Int64" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
      <summary>
        <see cref="T:System.Int64" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Int64" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)">
      <summary>
        <see cref="T:System.Single" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Single" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)">
      <summary>
        <see cref="T:System.Single" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.Single" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
      <summary>
        <see cref="T:System.UInt16" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.UInt16" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
      <summary>
        <see cref="T:System.UInt16" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.UInt16" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
      <summary>
        <see cref="T:System.UInt32" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.UInt32" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
      <summary>
        <see cref="T:System.UInt32" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.UInt32" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
      <summary>
        <see cref="T:System.UInt64" /> をビッグ エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がビッグ エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.UInt64" /> を格納できません。</exception>
    </member>
    <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
      <summary>
        <see cref="T:System.UInt64" /> をリトル エンディアンとしてバイトのスパンに書き込みます。</summary>
      <param name="destination">値がリトル エンディアンとして書き込まれるバイトのスパン。</param>
      <param name="value">バイトのスパンに書き込む値。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> が小さすぎて <see cref="T:System.UInt64" /> を格納できません。</exception>
    </member>
    <member name="T:System.Buffers.BuffersExtensions">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> の拡張メソッドを提供します。</summary>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0},System.Span{``0})">
      <summary>指定した <see cref="T:System.Span`1" /> に <see cref="T:System.Buffers.ReadOnlySequence`1" /> をコピーします。</summary>
      <param name="source">コピー元 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
      <param name="destination">コピー先の <see cref="T:System.Span`1" />。</param>
      <typeparam name="T">内の項目の型 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 。</typeparam>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0},``0)">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> で最初に見つかった <paramref name="item" /> の位置を返します。</summary>
      <param name="source">コピー元 <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
      <param name="value">
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> で検索する項目。</param>
      <typeparam name="T">内の項目の型 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 。</typeparam>
      <returns>最初に見つかった <paramref name="item" /> の位置が <see cref="M:System.SequencePosition.GetInteger" /> メソッドによって返されるオブジェクト。または、<see langword="Nullable&lt;SequencePosition&gt;.HasValue" /> プロパティが <see langword="false" /> であるオブジェクト。</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0})">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> を配列に変換します。</summary>
      <param name="sequence">配列に変換する読み取り専用シーケンス。</param>
      <typeparam name="T">内の項目の型 <see cref="T:System.Buffers.ReadOnlySequence`1" /> 。</typeparam>
      <returns>現在の読み取り専用シーケンス内のデータを格納する配列。</returns>
    </member>
    <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
      <summary>
        <paramref name="value" /> のコンテンツを <paramref name="writer" /> に書き込みます。</summary>
      <param name="writer">
        <paramref name="value" /> を書き込むバッファー ライター。</param>
      <param name="value">
        <paramref name="writer" /> に書き込まれる読み取り専用スパン。</param>
      <typeparam name="T">内の項目の型 <see cref="T:System.ReadOnlySpan`1" /> 。</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="writer" /> は <paramref name="value" /> よりも短いです。</exception>
    </member>
    <member name="T:System.Buffers.IBufferWriter`1">
      <summary>
        <typeparamref name="T" /> データを書き込むことができる出力シンクを表します。</summary>
      <typeparam name="T">内の項目の型 <see cref="T:System.Buffers.IBufferWriter`1" /> 。</typeparam>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
      <summary>
        <paramref name="count" /> データ項目が出力 <see cref="T:System.Span`1" /> または <see cref="T:System.Memory`1" /> に書き込まれたことを <see cref="T:System.Buffers.IBufferWriter`1" /> に通知します。</summary>
      <param name="count">
        <see cref="T:System.Span`1" /> または <see cref="T:System.Memory`1" /> に書き込まれたデータ項目の数。</param>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
      <summary>少なくとも要求されたサイズを持つ (<paramref name="sizeHint" /> で指定します)、書き込み先の <see cref="T:System.Memory`1" /> を返します。</summary>
      <param name="sizeHint">返される <see cref="T:System.Memory`1" /> の最小の長さ。 0 の場合は、空でないバッファーが返されます。</param>
      <exception cref="T:System.OutOfMemoryException">要求したバッファー サイズは使用できません。</exception>
      <returns>少なくとも <paramref name="sizeHint" /> のサイズを持つ <see cref="T:System.Memory`1" />。 <paramref name="sizeHint" /> が 0 の場合は、空でないバッファーを返します。</returns>
    </member>
    <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
      <summary>少なくとも要求されたサイズを持つ (<paramref name="sizeHint" /> で指定します)、書き込み先の <see cref="T:System.Span`1" /> を返します。</summary>
      <param name="sizeHint">返される <see cref="T:System.Span`1" /> の最小の長さ。 0 の場合は、空でないバッファーが返されます。</param>
      <returns>少なくとも <paramref name="sizeHint" /> のサイズを持つ <see cref="T:System.Span`1" />。 <paramref name="sizeHint" /> が 0 の場合は、空でないバッファーを返します。</returns>
    </member>
    <member name="T:System.Buffers.MemoryPool`1">
      <summary>メモリ ブロックのプールを表します。</summary>
      <typeparam name="T">メモリプール内の項目の型。</typeparam>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.#ctor">
      <summary>メモリ プールの新しいインスタンスを構築します。</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose">
      <summary>メモリ プールによって使用されているすべてのリソースを解放します。</summary>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
      <summary>メモリ プールによって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</summary>
      <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
    </member>
    <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
      <summary>T の要素を少なくとも <paramref name="minBufferSize" /> 個保持できるメモリ ブロックを返します。</summary>
      <param name="minBufferSize">メモリ プールで保持できる <typeparamref name="T" /> の要素の最小数。 値 -1 の場合、プールの既定のサイズに設定されたメモリ プールが返されます。</param>
      <returns>T の要素を少なくとも <paramref name="minBufferSize" /> 個保持できるメモリ ブロック。</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
      <summary>このプールでサポートされる最大バッファー サイズを取得します。</summary>
      <returns>このプールでサポートされる最大バッファーサイズ。</returns>
    </member>
    <member name="P:System.Buffers.MemoryPool`1.Shared">
      <summary>配列に基づいてメモリ プールのシングルトン インスタンスを取得します。</summary>
      <returns>メモリプールのシングルトンインスタンス。</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1">
      <summary>一連の <typeparamref name="T" /> を読み取ることができるシーケンスを表します。</summary>
      <typeparam name="T">読み取り専用シーケンス内の要素の型。</typeparam>
    </member>
    <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
      <summary>空の <see cref="T:System.Buffers.ReadOnlySequence`1" /> を返します。</summary>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
      <summary>
        <paramref name="array" /> から <see cref="T:System.Buffers.ReadOnlySequence`1" /> のインスタンスを作成します。</summary>
      <param name="array">読み取り専用シーケンスの作成元になる配列。</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
      <summary>配列のセクションから <see cref="T:System.Buffers.ReadOnlySequence`1" /> のインスタンスを作成します。</summary>
      <param name="array">読み取り専用シーケンスの作成元になる配列。</param>
      <param name="start">読み取り専用シーケンスに含める、配列の最初の要素の 0 から始まるインデックス。</param>
      <param name="length">読み取り専用シーケンスに含める要素の数。</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
      <summary>開始と終了のセグメントおよびそのセグメント内の対応するインデックスによって表されるリンクされたメモリ リストから <see cref="T:System.Buffers.ReadOnlySequence`1" /> のインスタンスを作成します。</summary>
      <param name="startSegment">リンクされたメモリ リストの最初のノード。</param>
      <param name="startIndex">
        <paramref name="startSegment" /> 内のシーケンスの先頭の位置。</param>
      <param name="endSegment">リンクされたメモリ リストの最後のノード。</param>
      <param name="endIndex">
        <paramref name="endSegment" /> 内のシーケンスの末尾の位置。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="startSegment" /> または <paramref name="endSegment" /> が <see langword="null" /> です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="startSegment" /> と <paramref name="endSegment" /> が異なるにもかかわらず、<paramref name="startSegment" /> の実行インデックスが <paramref name="endSegment" /> の実行インデックスより大きくなっています。

- または -

<paramref name="startSegment" /> は <paramref name="endSegment" /> と同じですが、<paramref name="endIndex" /> が <paramref name="startIndex" /> より小さくなっています。

- または -

<paramref name="startIndex" /> が <paramref name="startSegment" /> の基になるメモリ ブロックの長さを超えています。</exception>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
      <summary>
        <see cref="T:System.ReadOnlyMemory`1" /> から <see cref="T:System.Buffers.ReadOnlySequence`1" /> のインスタンスを作成します。</summary>
      <param name="memory">
        <typeparamref name="T" /> 型の要素のメモリの読み取り専用ブロック。</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> に対する列挙子を返します。</summary>
      <returns>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> に対する列挙子を返します。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetOffset(System.SequencePosition)">
      <summary>開始位置からのこのシーケンス内の <paramref name="position" /> のオフセットを返します。</summary>
      <param name="position">オフセットを取得する対象の <see cref="T:System.SequencePosition" />。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">位置が範囲外です。</exception>
      <returns>シーケンスの先頭からのオフセット。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
      <summary>
        <paramref name="offset" /> にあるシーケンスの先頭から新しい <see cref="T:System.SequencePosition" /> を返します。</summary>
      <param name="offset">シーケンスの先頭からのオフセット。</param>
      <returns>シーケンスの先頭から指定した <paramref name="offset" /> で始まるシーケンス位置を表すオブジェクト。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
      <summary>
        <paramref name="origin" /> 位置から指定したオフセットで開始する新しい <see cref="T:System.SequencePosition" /> を返します。</summary>
      <param name="offset">指定した <paramref name="origin" /> シーケンス位置からのオフセット。</param>
      <param name="origin">オフセットの開始位置を表すシーケンス位置。</param>
      <returns>指定した <paramref name="origin" /> 位置オブジェクトの <paramref name="offset" /> 位置から始まるシーケンス位置を表すオブジェクト。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="length" /> 個の項目を含むスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <param name="length">スライスの長さ。</param>
      <returns>インデックス <paramref name="start" /> で始まる現在のインスタンスからの <paramref name="length" /> 要素で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="end" /> (自身を含まない) で終わるスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <param name="end">スライスの末尾 (自身を含まない) の <see cref="T:System.SequencePosition" />。</param>
      <returns>現在の読み取り専用シーケンス内の <paramref name="start" /> インデックスから <paramref name="end" /> シーケンス位置の前までの項目で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、指定されたインデックスで始まり、読み取り専用シーケンスの末尾まで継続するスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示す開始インデックス。</param>
      <returns>インデックス <paramref name="start" /> から始まり、現在の読み取り専用シーケンスの末尾まで続くスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
      <summary>指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="length" /> 個の項目を含むスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <param name="length">スライスの長さ。</param>
      <returns>インデックス <paramref name="start" /> で始まる現在のインスタンスからの <paramref name="length" /> 要素で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="end" /> (自身を含まない) で終わるスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <param name="end">スライスの末尾 (自身を含まない)。</param>
      <returns>現在の読み取り専用シーケンス内の <paramref name="start" /> インデックスから <paramref name="end" /> シーケンス位置の前までの項目で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、指定されたシーケンス位置から始まり、読み取り専用シーケンスの末尾まで継続するスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示す開始 <see cref="T:System.SequencePosition" /> (自身を含む)。</param>
      <returns>シーケンス位置 <paramref name="start" /> から始まり、現在の読み取り専用シーケンスの末尾まで続くスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="length" /> 個の項目を含むスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示す開始 <see cref="T:System.SequencePosition" /> (自身を含む)。</param>
      <param name="length">スライスの長さ。</param>
      <returns>シーケンス位置 <paramref name="start" /> で始まる現在のインスタンスからの <paramref name="length" /> 要素で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="length" /> 個の項目を含むスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示す開始 <see cref="T:System.SequencePosition" /> (自身を含む)。</param>
      <param name="length">スライスの長さ。</param>
      <returns>シーケンス位置 <paramref name="start" /> で始まる現在のインスタンスからの <paramref name="length" /> 要素で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
      <summary>現在の <see cref="T:System.Buffers.ReadOnlySequence`1" /> から、<paramref name="start" /> で始まり、<paramref name="end" /> (自身を含まない) で終わるスライスを形成します。</summary>
      <param name="start">このスライスの開始位置を示す開始 <see cref="T:System.SequencePosition" /> (自身を含む)。</param>
      <param name="end">スライスの末尾 <see cref="T:System.SequencePosition" /> (自身を含まない)。</param>
      <returns>現在の読み取り専用シーケンス内の <paramref name="start" /> シーケンス位置から <paramref name="end" /> シーケンス位置の前までの項目で構成されるスライス。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
      <summary>現在のシーケンスを表す文字列を返します。</summary>
      <returns>現在のシーケンスを表す文字列。</returns>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
      <summary>
        <paramref name="position" /> の後の次のセグメントの取得を試行し、操作が成功したかどうかを示す値を返します。</summary>
      <param name="position">現在のシーケンス位置。</param>
      <param name="memory">
        <paramref name="position" /> の後の次のセグメントを含む読み取り専用メモリ スパン。</param>
      <param name="advance">
        <paramref name="position" /> が次のセグメントの先頭である場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
      <returns>次のセグメントがメソッドによって返された場合は <see langword="true" /> を返し、読み取り専用シーケンスの末尾に到達した場合は <see langword="false" /> を返します。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.End">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> の末尾の位置を取得します。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.First">
      <summary>最初のセグメントから <see cref="T:System.ReadOnlyMemory`1" /> を取得します。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
      <summary>最初のセグメントから <see cref="T:System.ReadOnlySpan`1" /> を取得します。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> が空かどうかを示す値を取得します。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> に 1 つの <see cref="T:System.ReadOnlyMemory`1" /> セグメントが含まれているかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> 読み取り専用シーケンスが空の場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Length">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> の長さを取得します。</summary>
      <returns>読み取り専用シーケンスの長さ。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Start">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> の先頭までの位置を取得します。</summary>
    </member>
    <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> に対する列挙子を表します。</summary>
      <typeparam name="T" />
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
      <summary>列挙子を初期化します。</summary>
      <param name="sequence">列挙する <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
    </member>
    <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
      <summary>
        <see cref="T:System.ReadOnlyMemory`1" /> 内の次の <see cref="T:System.Buffers.ReadOnlySequence`1" /> に移動します。</summary>
      <returns>列挙子が次の項目に正常に進んだ場合は <see langword="true" />、シーケンスの末尾に到達した場合は <see langword="false" /> です。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
      <summary>現在の <see cref="T:System.ReadOnlyMemory`1" /> を取得します。</summary>
      <returns>現在の <see cref="T:System.ReadOnlyMemory`1" /> です。</returns>
    </member>
    <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
      <summary>
        <see cref="T:System.ReadOnlyMemory`1" /> ノードのリンク リストを表します。</summary>
      <typeparam name="T">読み取り専用のシーケンスセグメント内の要素の型。</typeparam>
    </member>
    <member name="M:System.Buffers.ReadOnlySequenceSegment`1.#ctor">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequenceSegment`1" /> クラスの新しいインスタンスを初期化します。</summary>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
      <summary>現在のノードの <see cref="T:System.ReadOnlyMemory`1" /> 値を取得または設定します。</summary>
      <returns>
        <see cref="T:System.ReadOnlyMemory`1" />現在のノードの値。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
      <summary>次のノードを取得または設定します。</summary>
      <returns>次のノード。</returns>
    </member>
    <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
      <summary>現在のノードの前にあるノードの長さの合計を取得または設定します。</summary>
      <returns>現在のノードの前のノード長の合計。</returns>
    </member>
    <member name="T:System.Buffers.SequenceReader`1">
      <summary>パフォーマンスと最小またはゼロのヒープ割り当てに重点を置いて、<see cref="T:System.Buffers.ReadOnlySequence`1" /> からバイナリおよびテキスト データを読み取るためのメソッドを提供します。</summary>
      <typeparam name="T">読み取り専用シーケンスの型。</typeparam>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
      <summary>指定した <see cref="T:System.Buffers.ReadOnlySequence`1" /> に対して <see cref="T:System.Buffers.SequenceReader`1" /> を作成します。</summary>
      <param name="sequence">
        <see cref="T:System.Buffers.SequenceReader`1" /> を作成する対象の読み取り専用シーケンス。</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
      <summary>指定した項目数の分、リーダーを前進させます。</summary>
      <param name="count">前進する項目数。</param>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
      <summary>指定された <paramref name="value" /> の連続するインスタンスを超えて前進させます。</summary>
      <param name="value">リーダーを前進させるために通過する値。</param>
      <returns>リーダーが前進した位置の数。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
      <summary>指定した値のいずれかの連続するインスタンスを超えて前進させます。</summary>
      <param name="value0">スキップする 1 番目の値。</param>
      <param name="value1">スキップする 2 番目の値。</param>
      <returns>リーダーが前進した位置の数。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
      <summary>指定した 3 つの値のいずれかの連続するインスタンスを超えて前進させます。</summary>
      <param name="value0">スキップする 1 番目の値。</param>
      <param name="value1">スキップする 2 番目の値。</param>
      <param name="value2">スキップする 3 番目の値。</param>
      <returns>リーダーが前進した位置の数。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
      <summary>指定した 4 つの値のいずれかの連続するインスタンスを超えて前進させます。</summary>
      <param name="value0">スキップする 1 番目の値。</param>
      <param name="value1">スキップする 2 番目の値。</param>
      <param name="value2">スキップする 3 番目の値。</param>
      <param name="value3">スキップする 4 番目の値。</param>
      <returns>リーダーが前進した位置の数。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
      <summary>指定したいずれかの <paramref name="values" /> の連続するインスタンスをスキップします。</summary>
      <param name="values">スキップされる値。</param>
      <returns>リーダーが前進した位置の数。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.AdvanceToEnd">
      <summary>リーダーをシーケンスの末尾に移動します。</summary>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
      <summary>指定された値がシーケンスの次にあるかどうかを確認します。</summary>
      <param name="next">次の項目を比較する値。</param>
      <param name="advancePast">
        <paramref name="next" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <returns>値がシーケンスで次に位置する場合、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>読み取り専用スパンで指定された値がシーケンスの次にあるかどうかを確認します。</summary>
      <param name="next">次の項目を比較するスパン。</param>
      <param name="advancePast">
        <paramref name="next" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <returns>値がシーケンスで次に位置する場合、<see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
      <summary>指定した項目数の分、リーダーを戻します。</summary>
      <param name="count">項目の数。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> が負か <see cref="P:System.Buffers.SequenceReader`1.Consumed" /> を超えています。</exception>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
      <summary>指定された区切り記号を検索し、見つかった場合は必要に応じてそれを超えて前進します。</summary>
      <param name="delimiter">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> が見つかった場合に通過するには <see langword="true" />、それ以外の場合は <see langword="false" />。</param>
      <returns>指定された <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
      <summary>指定した任意の数の区切り記号を検索し、必要に応じて見つかった 1 つ目を超えて前進します。</summary>
      <param name="delimiters">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> のとき、指定された <paramref name="delimiters" /> の最初のインスタンスを通過します。<see langword="false" /> のとき、区切り記号を通過しません。</param>
      <returns>指定された <paramref name="delimiters" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
      <summary>スパンを埋めるのに十分なデータがある場合は、現在の位置から指定したコピー先スパンにデータをコピーします。</summary>
      <param name="destination">コピー先のスパン。</param>
      <returns>
        <paramref name="destination" /> スパンを完全に埋める十分なデータがある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
      <summary>リーダーを前進させずに、次の値をピークします。</summary>
      <param name="value">次の値、またはリーダーの末尾の場合は既定値。</param>
      <returns>リーダーが末尾になく、ピーク操作が成功した場合は <see langword="true" />、リーダーの末尾にある場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryPeek(System.Int64,`0@)">
      <summary>リーダーを進めず、指定されたオフセットに次の値をピークします。</summary>
      <param name="offset">現在位置からのオフセット。</param>
      <param name="value">次の値、またはリーダーの末尾の場合は既定値。</param>
      <returns>リーダーが末尾になく、ピーク操作が成功した場合は <see langword="true" />、リーダーの末尾にある場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
      <summary>次の値を読み取ってリーダーを前進させます。</summary>
      <param name="value">次の値、またはリーダーの末尾の場合は既定値。</param>
      <returns>リーダーが末尾になく、読み取り操作が成功した場合は <see langword="true" />、リーダーの末尾にある場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
      <summary>
        <paramref name="delimiterEscape" /> の後の区切り記号は無視して、指定された <paramref name="delimiter" /> まですべての読み取りを試みます。</summary>
      <param name="sequence">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiter">検索する区切り記号。</param>
      <param name="delimiterEscape">
        <paramref name="delimiter" /> の直後がスキップされることを示す値。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
      <summary>指定された <paramref name="delimiter" /> まですべての読み取りを試みます。</summary>
      <param name="sequence">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiter">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>読み取り専用スパンとして指定された全体の区切り記号が一致するまで、データの読み取りが試行されます。</summary>
      <param name="sequence">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiter">1 つ以上の区切り記号を含む読み取り専用スパン。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
      <summary>
        <paramref name="delimiterEscape" /> の後の区切り記号は無視して、指定された <paramref name="delimiter" /> まですべての読み取りを試みます。</summary>
      <param name="span">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiter">検索する区切り記号。</param>
      <param name="delimiterEscape">
        <paramref name="delimiter" /> の直後がスキップされることを示す値。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
      <summary>指定された <paramref name="delimiter" /> まですべての読み取りを試みます。</summary>
      <param name="span">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiter">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> 値が見つかった場合、通過するときは <see langword="true" />。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>指定された <paramref name="delimiter" /> まですべての読み取りを試みます。</summary>
      <param name="sequence">読み取りデータ (ある場合)。</param>
      <param name="delimiter">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <paramref name="delimiter" /> が見つかった場合に通過する場合は <see langword="true" />。</param>
      <param name="span">読み取りデータ (ある場合)。</param>
      <returns>
        <paramref name="delimiter" /> が見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>指定したいずれかの <paramref name="delimiters" /> まですべての読み取りを試みます。</summary>
      <param name="sequence">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiters">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> のとき、指定された <paramref name="delimiters" /> の最初に見つかったインスタンスを通過します。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiters" /> のいずれかが見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
      <summary>指定したいずれかの <paramref name="delimiters" /> まですべての読み取りを試みます。</summary>
      <param name="span">メソッドから戻るときに、読み取られたデータが含まれます (ある場合)。</param>
      <param name="delimiters">検索する区切り記号。</param>
      <param name="advancePastDelimiter">
        <see langword="true" /> のとき、指定された <paramref name="delimiters" /> の最初に見つかったインスタンスを通過します。それ以外の場合は、<see langword="false" />。</param>
      <returns>
        <paramref name="delimiters" /> のいずれかが見つかった場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Consumed">
      <summary>リーダーで処理された <typeparamref name="T" /> 値の合計数を取得します。</summary>
      <returns>リーダーによって処理された値の合計数。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
      <summary>
        <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 内の現在のセグメントが格納されている <see cref="T:System.Span`1" /> を取得します。</summary>
      <returns>シーケンス内の現在のセグメントを含むスパン。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
      <summary>
        <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 内のインデックスを取得します。</summary>
      <returns>内のインデックス <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.End">
      <summary>
        <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> にこれ以上データがないかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> にデータがそれ以上ない場合は <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Length">
      <summary>リーダーの <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 内の項目の数を取得します。</summary>
      <returns>リーダーの内の項目の数 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Position">
      <summary>
        <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 内の現在の位置を取得します。</summary>
      <returns>内の現在の位置 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Remaining">
      <summary>リーダーの <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 内の残りの項目を取得します。</summary>
      <returns>リーダーのその他の項目 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /></returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.Sequence">
      <summary>リーダーの基になる <see cref="T:System.Buffers.ReadOnlySequence`1" /> を取得します。</summary>
      <returns>リーダーの基になる読み取り専用シーケンス。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSequence">
      <summary>
        <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> の未読の部分を取得します。</summary>
      <returns>の未読の部分 <see cref="P:System.Buffers.SequenceReader`1.Sequence" /> 。</returns>
    </member>
    <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
      <summary>
        <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> の未読の部分を取得します。</summary>
      <returns>の未読の部分 <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan" /> 。</returns>
    </member>
    <member name="T:System.Buffers.SequenceReaderExtensions">
      <summary>バイナリ データからのエンディアン固有の数値の読み取りを許可する <see cref="T:System.Buffers.SequenceReader`1" /> クラスの拡張機能を提供します。</summary>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>ビッグ エンディアンとしての <see cref="T:System.Int16" /> の読み取りを試行します。</summary>
      <param name="reader">値の読み取り元となるバイト シーケンス リーダー インスタンス。</param>
      <param name="value">メソッドから制御が戻るときに、ビッグ エンディアンとして、バイト シーケンス リーダーから読み取られる値。</param>
      <returns>読み取り操作が成功した場合は <see langword="true" />、<see cref="T:System.Int16" /> のための十分なデータがない場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>ビッグ エンディアンとしての <see cref="T:System.Int32" /> の読み取りを試行します。</summary>
      <param name="reader">値の読み取り元となるバイト シーケン スリーダー。</param>
      <param name="value">メソッドから制御が戻るときに、ビッグ エンディアンとして、バイト シーケンス リーダーから読み取られる値。</param>
      <returns>読み取り操作が成功した場合は <see langword="true" />、<see cref="T:System.Int32" /> のための十分なデータがない場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>ビッグ エンディアンとしての <see cref="T:System.Int64" /> の読み取りを試行します。</summary>
      <param name="reader">値の読み取り元となるバイト シーケンス リーダー インスタンス。</param>
      <param name="value">メソッドから制御が戻るときに、ビッグ エンディアンとして、バイト シーケンス リーダーから読み取られる値。</param>
      <returns>読み取り操作が成功した場合は <see langword="true" />、<see cref="T:System.Int64" /> のための十分なデータがない場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int16@)">
      <summary>リトル エンディアンとしての <see cref="T:System.Int16" /> の読み取りを試行します。</summary>
      <param name="reader">値の読み取り元となるバイト シーケンス リーダー インスタンス。</param>
      <param name="value">メソッドから制御が戻るときに、リトル エンディアンとして、バイト シーケンス リーダーから読み取られる値。</param>
      <returns>読み取り操作が成功した場合は <see langword="true" />、<see cref="T:System.Int16" /> のための十分なデータがない場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int32@)">
      <summary>リトル エンディアンとしての <see cref="T:System.Int32" /> の読み取りを試行します。</summary>
      <param name="reader">値の読み取り元となるバイト シーケンス リーダー インスタンス。</param>
      <param name="value">メソッドから制御が戻るときに、リトル エンディアンとして、バイト シーケンス リーダーから読み取られる値。</param>
      <returns>読み取り操作が成功した場合は <see langword="true" />、<see cref="T:System.Int32" /> のための十分なデータがない場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte},System.Int64@)">
      <summary>リトル エンディアンとしての <see cref="T:System.Int64" /> の読み取りを試行します。</summary>
      <param name="reader">値の読み取り元となるバイト シーケンス リーダー インスタンス。</param>
      <param name="value">メソッドから制御が戻るときに、リトル エンディアンとして、バイト シーケンス リーダーから読み取られる値。</param>
      <returns>読み取り操作が成功した場合は <see langword="true" />、<see cref="T:System.Int64" /> のための十分なデータがない場合は <see langword="false" />。</returns>
    </member>
    <member name="T:System.Buffers.StandardFormat">
      <summary>実際の文字列を使用せずに標準書式の文字列を表します。</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.MaxPrecision">
      <summary>最大有効桁数の値を定義します。</summary>
    </member>
    <member name="F:System.Buffers.StandardFormat.NoPrecision">
      <summary>書式が有効桁数を使用しないか、有効桁数が指定されていないことを示します。</summary>
    </member>
    <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
      <summary>
        <see cref="T:System.Buffers.StandardFormat" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="symbol">'G'、'D'、'X' などの、型固有の書式指定子。</param>
      <param name="precision">0 から 99 までの任意の有効桁数、または特殊な値 <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> (既定)。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="symbol" /> が <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> ではなく、その値が <see cref="F:System.Buffers.StandardFormat.MaxPrecision" /> を超えています。

- または -

<paramref name="symbol" /> を <see cref="T:System.Byte" /> に変換できません。</exception>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
      <summary>指定した <see cref="T:System.Buffers.StandardFormat" /> が現在のインスタンスと等しいかどうかを示す値を返します。</summary>
      <param name="other">現在のインスタンスと比較する対象の形式。</param>
      <returns>2 つのインスタンスが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
      <summary>指定したオブジェクトが、現在のインスタンスと等しい <see cref="T:System.Buffers.StandardFormat" /> オブジェクトであるかどうかを示す値を返します。</summary>
      <param name="obj">現在のインスタンスと比較する対象のオブジェクト。</param>
      <returns>2 つのインスタンスが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.GetHashCode">
      <summary>このインスタンスのハッシュ コードを返します。</summary>
      <returns>対象のインスタンスのハッシュ コード。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>2 つの <see cref="T:System.Buffers.StandardFormat" /> インスタンスが等しいかどうかを示す値を返します。</summary>
      <param name="left">比較対象となる最初の書式。</param>
      <param name="right">比較対象となる 2 番目の書式。</param>
      <returns>2 つのインスタンスが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
      <summary>
        <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> の有効桁数を使用して、文字を <see cref="T:System.Buffers.StandardFormat" /> インスタンスに変換します。</summary>
      <param name="symbol">
        <see cref="T:System.Buffers.StandardFormat" /> 値に変換する文字。</param>
      <returns>
        <paramref name="symbol" /> と等しい <see cref="P:System.Buffers.StandardFormat.Symbol" /> プロパティおよび <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> と等しい <see cref="P:System.Buffers.StandardFormat.Precision" /> プロパティを含む書式。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
      <summary>2 つの <see cref="T:System.Buffers.StandardFormat" /> インスタンスが等しくないかどうかを判断します。</summary>
      <param name="left">比較対象となる最初の書式。</param>
      <param name="right">比較対象となる 2 番目の書式。</param>
      <returns>2 つの書式が等しくない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
      <summary>
        <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> の有効桁数を使用して、<see langword="ReadOnlySpan&lt;System.Char&gt;" /> を <see cref="T:System.Buffers.StandardFormat" /> インスタンスに変換します。</summary>
      <param name="format">解析対象の文字が含まれる読み取り専用のスパン。</param>
      <returns>
        <see cref="P:System.Buffers.StandardFormat.Symbol" /> プロパティの値が <paramref name="format" /> の文字で、<see cref="P:System.Buffers.StandardFormat.Precision" /> プロパティの値が <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> である値。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
      <summary>従来の .NET 標準書式文字列を <see cref="T:System.Buffers.StandardFormat" /> インスタンスに変換します。</summary>
      <param name="format">従来の .NET 標準書式文字列。</param>
      <exception cref="T:System.FormatException">
        <paramref name="format" /> は有効な標準書式指定文字列ではありません。</exception>
      <returns>書式。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.ToString">
      <summary>この書式の文字列表現を返します。</summary>
      <returns>この書式の文字列表現。</returns>
    </member>
    <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
      <summary>
        <see cref="T:System.Buffers.StandardFormat" /> インスタンスへの <see langword="ReadOnlySpan&lt;Char&gt;" /> の変換を試みて、解析操作が成功したかどうかを示す値を返します。</summary>
      <param name="format">変換対象の文字が含まれる読み取り専用のスパン。</param>
      <param name="result">操作が正常に終了した場合は、メソッドから戻るときに、解析された <see cref="T:System.Buffers.StandardFormat" /> インスタンスが格納されます。</param>
      <returns>解析操作が正常に実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.HasPrecision">
      <summary>書式に定義された有効桁数が含まれるかどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> 形式の有効桁数が以外の場合は <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> 。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.IsDefault">
      <summary>現在のインスタンスが既定の書式かどうかを示す値を取得します。</summary>
      <returns>
        <see langword="true" /> 現在のインスタンスが既定の形式である場合は。それ以外の場合は <see langword="false" /> 。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Precision">
      <summary>書式の有効桁数のコンポーネントを取得します。</summary>
      <returns>有効桁数コンポーネント <see cref="F:System.Buffers.StandardFormat.NoPrecision" /> 。 0 ~ 9 の範囲で指定できます。</returns>
    </member>
    <member name="P:System.Buffers.StandardFormat.Symbol">
      <summary>書式の文字のコンポーネントを取得します。</summary>
      <returns>形式の文字部分。</returns>
    </member>
    <member name="T:System.Buffers.Text.Base64">
      <summary>バイナリ データと base 64 で表される UTF-8 でエンコードされたテキスト間の変換を行います。</summary>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>base 64 として表される UTF-8 でエンコードされたテキストのスパンをバイナリ データにデコードします。 入力が 4 の倍数でない場合は、可能な限り 4 の倍数に最も近い値にデコードされます。</summary>
      <param name="utf8">デコードが必要な base 64 方式の UTF-8 でエンコードされたテキストを含む入力スパン。</param>
      <param name="bytes">操作の結果 (つまり、デコードされたバイナリ データ) を含む出力スパン。</param>
      <param name="bytesConsumed">操作中に使用された入力バイト数。 必要な場合、これを使用して後続の呼び出しの入力をスライスできます。</param>
      <param name="bytesWritten">出力スパンに書き込まれたバイト数。 必要な場合、これを使用して後続の呼び出しの出力をスライスできます。</param>
      <param name="isFinalBlock">デコードするデータ全体が入力スパンに含まれている場合は <see langword="true" /> (既定値)。 一部のデータが入力スパンに含まれており、後続のデータがある場合は <see langword="false" />。</param>
      <returns>デコード操作の状態を示す列挙値の 1 つ。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
      <summary>base 64 方式の UTF-8 でエンコードされたテキストのスパン (インプレース) をバイナリ データにデコードします。 デコードされたバイナリ出力は、入力に含まれるテキスト データよりも小さくなります (この操作ではデータがデフレートされます)。 入力が 4 の倍数でない場合、このメソッドではデータがデコードされません。</summary>
      <param name="buffer">デコードが必要な base-64 テキスト データを含む入力スパン。</param>
      <param name="bytesWritten">バッファーに書き込まれたバイト数。</param>
      <returns>デコード操作の状態を示す列挙値の 1 つ。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
      <summary>バイナリ データのスパンを base 64 として表される UTF-8 でエンコードされたテキストにエンコードします。</summary>
      <param name="bytes">エンコードが必要なバイナリ データを含む入力スパン。</param>
      <param name="utf8">操作の結果 (つまり、base 64 方式の UTF-8 でエンコードされたテキスト) を含む出力スパン。</param>
      <param name="bytesConsumed">操作中に使用された入力バイト数。 必要な場合、これを使用して後続の呼び出しの入力をスライスできます。</param>
      <param name="bytesWritten">出力スパンに書き込まれたバイト数。 必要な場合、これを使用して後続の呼び出しの出力をスライスできます。</param>
      <param name="isFinalBlock">エンコードするデータ全体が入力スパンに含まれている場合は <see langword="true" /> (既定値)。 一部のデータが入力スパンに含まれており、後続のデータがある場合は <see langword="false" />。</param>
      <returns>エンコード操作の状態を示す列挙値の 1 つ。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
      <summary>バイナリ データのスパン (インプレース) を base 64 として表される UTF-8 でエンコードされたテキストにエンコードします。 エンコードされたテキスト出力は、入力に含まれるバイナリ データよりも大きくなります (この操作ではデータがインフレートされます)。</summary>
      <param name="buffer">エンコードが必要なバイナリ データを含む入力スパン。 このメソッドではインプレース変換が実行されるので、操作の結果を格納するための十分な大きさが必要です。</param>
      <param name="dataLength">エンコードが必要な、バッファー内に含まれるバイナリ データのバイト数。 この値はバッファー長より小さくしてください。</param>
      <param name="bytesWritten">バッファーに書き込まれたバイト数。</param>
      <returns>エンコード操作の状態を示す列挙値の 1 つ。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
      <summary>指定された長さのバイト スパン内の base-64 でエンコードされたテキストをデコードする場合は、結果の最大長 (バイト数) を返します。</summary>
      <param name="length">バイト スパンのサイズ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> が 0 未満です。</exception>
      <returns>結果の最大長 (バイト単位)。</returns>
    </member>
    <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
      <summary>指定された長さのバイト スパン内のバイナリ データをエンコードする場合は、結果の最大長 (バイト数) を返します。</summary>
      <param name="length">バイト スパンのサイズ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="length" /> は 0 未満または 1610612733 より大きくなります (エンコードによってデータが 4/3 倍にインフレートされるため)。</exception>
      <returns>結果の最大長 (バイト単位)。</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Formatter">
      <summary>共通データ型を Utf8 文字列として書式設定する静的メソッドを提供します。</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Boolean" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Byte" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.DateTime" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.DateTimeOffset" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Decimal" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Double" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Guid" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Int16" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Int32" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Int64" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.SByte" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.Single" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.TimeSpan" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.UInt16" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.UInt32" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
      <summary>UTF8 文字列として <see cref="T:System.UInt64" /> を書式設定します。</summary>
      <param name="value">書式を変換する値。</param>
      <param name="destination">UTF8 形式の値を書き込むバッファー。</param>
      <param name="bytesWritten">メソッドが戻るとき、書式設定されたテキストの長さがバイト単位で含まれます。</param>
      <param name="format">使用する標準書式。</param>
      <returns>書式設定操作が成功した場合、<see langword="true" />。<paramref name="buffer" /> が小さすぎる場合、<see langword="false" />。</returns>
    </member>
    <member name="T:System.Buffers.Text.Utf8Parser">
      <summary>Utf8 文字列を一般的なデータ型に解析するための静的メソッドを提供します。</summary>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Boolean" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Byte" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.DateTime" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.DateTimeOffset" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Decimal" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Double" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Guid" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Int16" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Int32" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Int64" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.SByte" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.Single" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.TimeSpan" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.UInt16" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.UInt32" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
      <summary>Utf8 文字列の先頭で <see cref="T:System.UInt64" /> を解析します。</summary>
      <param name="source">解析する Utf8 文字列。</param>
      <param name="value">メソッドが戻るとき、解析操作に成功していれば、<paramref name="source" /> から解析された値が含まれます。</param>
      <param name="bytesConsumed">解析操作に成功した場合、メソッドが戻るとき、解析された部分文字列の長さがバイト単位で含まれます。 メソッドが失敗した場合、<paramref name="bytesConsumed" /> が 0 に設定されます。</param>
      <param name="standardFormat">Utf8 文字列の予期される形式。</param>
      <returns>成功した場合は <see langword="true" />。文字列が構文上、有効ではない場合、あるいはオーバーフローまたはアンダーフローが発生した場合は <see langword="false" />。</returns>
    </member>
    <member name="T:System.MemoryExtensions">
      <summary>
        <see cref="T:System.Memory`1" />、<see cref="T:System.ReadOnlyMemory`1" />、<see cref="T:System.Span`1" />、<see cref="T:System.ReadOnlySpan`1" /> など、メモリおよびスパンに関連する型の拡張メソッドを提供します。</summary>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String)">
      <summary>挿入先の文字列の一部に新しい <see langword="ReadOnlyMemory&lt;Char&gt;" /> を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <returns>文字列の読み取り専用の文字メモリ表現。あるいは、<paramref name="text" /> が <see langword="null" /> の場合は <see langword="default" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
      <summary>指定したインデックスを開始位置として、挿入先の文字列の一部に対して新しい <see langword="ReadOnlyMemory&lt;Char&gt;" /> を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <param name="startIndex">このスライスの開始位置を示すインデックス。</param>
      <returns>文字列の読み取り専用の文字メモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
      <summary>指定した文字位置を開始位置として、挿入先の文字列の一部に対して新しい <see langword="ReadOnlyMemory&lt;Char&gt;" /> を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> が <paramref name="text" /> の範囲内にありません (<paramref name="start" /> が &lt; 0、または &gt; <c>text.Length</c>)。</exception>
      <returns>文字列の読み取り専用の文字メモリ表現。あるいは、<paramref name="text" /> が <see langword="null" /> の場合は <see langword="default" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
      <summary>指定した位置 (長さを含む) を開始位置として、挿入先の文字列の一部に対して新しい <see langword="ReadOnlyMemory&lt;Char&gt;" /> を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <param name="length">スライスに求められる長さ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" />、または <paramref name="start" /> + <paramref name="length" /> が <paramref name="text" /> の範囲内にありません。</exception>
      <returns>文字列の読み取り専用の文字メモリ表現。あるいは、<paramref name="text" /> が <see langword="null" /> の場合は <see langword="default" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
      <summary>挿入先の文字列の指定範囲に新しい <see langword="ReadOnlyMemory&lt;Char&gt;" /> を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <param name="range">スライスされた文字列の開始と長さを示す範囲。</param>
      <returns>文字列の読み取り専用の文字メモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
      <summary>挿入先の配列に新しいメモリ領域を作成します。</summary>
      <param name="array">変換する配列。</param>
      <typeparam name="T">配列の型。</typeparam>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
      <summary>指定されたインデックスを開始位置として、配列の終わりまで、挿入先の配列の一部に新しいメモリ領域を作成します。</summary>
      <param name="array">変換する配列。</param>
      <param name="startIndex">配列の最初の位置。</param>
      <typeparam name="T">配列の型。</typeparam>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
      <summary>指定された位置を開始位置として、配列の終わりまで、挿入先の配列の一部に新しいメモリ領域を作成します。</summary>
      <param name="array">対象となる配列。</param>
      <param name="start">メモリの開始位置を示すインデックス。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> は共変であり、配列の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> インデックスが 0 未満であるか、<see langword="array.Length" /> を超えています。</exception>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
      <summary>指定された位置を開始位置とし、指定された長さで、挿入先の配列の一部に新しいメモリ領域を作成します。</summary>
      <param name="array">対象となる配列。</param>
      <param name="start">メモリ領域の開始位置を示すインデックス。</param>
      <param name="length">メモリ領域の項目数。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> は共変であり、配列の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" />、または <paramref name="start" /> + <paramref name="length" /> が <paramref name="array" /> の範囲内にありません。</exception>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
      <summary>範囲の開始インデックス (含む) を開始位置とし、範囲の終了インデックス (含まない) を終了位置として、挿入先の配列の一部に新しいメモリ領域を作成します。</summary>
      <param name="array">変換する配列。</param>
      <param name="range">配列から変換する範囲。</param>
      <typeparam name="T">配列の型。</typeparam>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
      <summary>挿入先の配列セグメントの一部に新しいメモリ領域を作成します。</summary>
      <param name="segment">変換するセグメント。</param>
      <typeparam name="T">セグメントの型。</typeparam>
      <returns>セグメントのメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
      <summary>指定された位置を開始位置として、セグメントの終わりまで、挿入先の配列セグメントの一部に新しいメモリ領域を作成します。</summary>
      <param name="segment">挿入先の配列セグメント。</param>
      <param name="start">メモリの開始位置を示すインデックス。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> は共変であり、<paramref name="segment" /> の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> が 0 未満であるか、または <see langword="segment.Count" /> を超えています。</exception>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>指定された位置を開始位置とし、指定された長さで、挿入先の配列セグメントの一部に新しいメモリ領域を作成します。</summary>
      <param name="segment">挿入先の配列セグメント。</param>
      <param name="start">メモリの開始位置を示すインデックス。</param>
      <param name="length">メモリの項目数。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> は共変であり、配列の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" />、または <paramref name="start" /> + <paramref name="length" /> が <paramref name="segment" /> の範囲内にありません。</exception>
      <returns>配列の全体または一部のメモリ表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String)">
      <summary>指定された位置から指定された文字数だけ、挿入先の文字列の一部に対して読み取り専用の新しい範囲を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <returns>文字列の読み取り専用のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
      <summary>指定された位置から文字列の終わりまで、挿入先の文字列の一部に対して読み取り専用の新しい範囲を作成します。</summary>
      <param name="text">対象の文字列。</param>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="text" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> が 0 未満であるか、または <see langword="text.Length" /> を超えています。</exception>
      <returns>文字列の読み取り専用のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
      <summary>文字列に対して新しい読み取り専用のスパンを作成します。</summary>
      <param name="text">対象の文字列。</param>
      <param name="start">このスライスの開始位置を示すインデックス。</param>
      <param name="length">スライスに求められる長さ。</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" />、または <paramref name="start" /> + <paramref name="length" /> が <paramref name="text" /> の範囲内にありません。</exception>
      <returns>文字列の読み取り専用のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
      <summary>挿入先の配列に新しいスパンを作成します。</summary>
      <param name="array">変換する配列。</param>
      <typeparam name="T">配列の型。</typeparam>
      <returns>配列のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
      <summary>
        <see cref="T:System.Index" /> 値によって定義される挿入先の配列の一部に新しいスパンを作成します。</summary>
      <param name="array">変換する配列。</param>
      <param name="startIndex">開始インデックス。</param>
      <typeparam name="T">配列型。</typeparam>
      <returns>配列のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
      <summary>指定された位置を開始位置として、配列の終わりまで、挿入先の配列の一部に新しいスパンを作成します。</summary>
      <param name="array">変換する配列。</param>
      <param name="start">配列の変換元の初期インデックス。</param>
      <typeparam name="T">配列の型。</typeparam>
      <returns>配列のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
      <summary>指定された位置から指定された長さだけ、挿入先の配列の一部に対して新しいスパンを作成します。</summary>
      <param name="array">対象となる配列。</param>
      <param name="start">スパンの開始位置を示すインデックス。</param>
      <param name="length">スパン内の項目の数。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> は共変であり、配列の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" />、または <paramref name="start" /> + <paramref name="length" /> が <paramref name="text" /> の範囲内にありません。</exception>
      <returns>配列のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
      <summary>
        <see cref="T:System.Range" /> 値によって定義される挿入先の配列の一部に対して新しいスパンを作成します。</summary>
      <param name="array">変換する配列。</param>
      <param name="range">変換する配列の範囲。</param>
      <typeparam name="T">配列の型。</typeparam>
      <returns>配列のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
      <summary>挿入先の配列セグメントに新しいスパンを作成します。</summary>
      <param name="segment">変換する配列セグメント。</param>
      <typeparam name="T">配列セグメントの型。</typeparam>
      <returns>配列セグメントのスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
      <summary>指定されたインデックスを開始位置とし、セグメントの終わりで終了する挿入先の配列セグメントの一部に新しいスパンを作成します。</summary>
      <param name="segment">挿入先の配列セグメント。</param>
      <param name="startIndex">スパンの開始位置を示すインデックス。</param>
      <typeparam name="T">配列セグメントの型。</typeparam>
      <returns>配列セグメントのスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
      <summary>指定された位置からセグメントの終わりまで、挿入先の配列セグメントの一部に対して新しいスパンを作成します。</summary>
      <param name="segment">挿入先の配列セグメント。</param>
      <param name="start">スパンの開始位置を示すインデックス。</param>
      <typeparam name="T">配列セグメントの型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> は共変であり、配列の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> が 0 未満であるか、または <see langword="segment.Count" /> を超えています。</exception>
      <returns>配列セグメントのスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
      <summary>指定された位置から指定された長さだけ、挿入先の配列セグメントの一部に対して新しいスパンを作成します。</summary>
      <param name="segment">挿入先の配列セグメント。</param>
      <param name="start">スパンの開始位置を示すインデックス。</param>
      <param name="length">スパン内の項目の数。</param>
      <typeparam name="T">配列セグメントの型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="segment" /> は共変であり、配列の型は <see langword="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" />、<paramref name="length" />、または <paramref name="start" /> + <paramref name="length" /> が <paramref name="segment" /> の範囲内にありません。</exception>
      <returns>配列のスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
      <summary>範囲の開始インデックスと終了インデックスを使用し、挿入先の配列セグメントの一部に対して新しいスパンを作成します。</summary>
      <param name="segment">挿入先の配列セグメント。</param>
      <param name="range">配列のスライスに使用する開始インデックスと終了インデックスを持つ範囲。</param>
      <typeparam name="T">配列セグメントの型。</typeparam>
      <returns>配列セグメントのスパン表現。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
      <summary>指定した <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用し、並べ替えられた <see cref="T:System.ReadOnlySpan`1" /> 全体の中から値を検索します。</summary>
      <param name="span">検索する並べ替えられた <see cref="T:System.ReadOnlySpan`1" />。</param>
      <param name="comparable">比較する場合に使用する <see cref="T:System.IComparable`1" />。</param>
      <typeparam name="T">スパンの要素の種類。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="comparable" /> が見つかった場合は、並べ替えられた <paramref name="span" /> 内の <paramref name="comparable" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="comparable" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.ReadOnlySpan`1.Length" /> のビットごとの補数です。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
      <summary>指定した <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用し、並べ替えられた <see cref="T:System.Span`1" /> 全体の中から値を検索します。</summary>
      <param name="span">検索する並べ替えられた <see cref="T:System.Span`1" />。</param>
      <param name="comparable">比較する場合に使用する <see cref="T:System.IComparable`1" />。</param>
      <typeparam name="T">スパンの要素の種類。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="comparable" /> が見つかった場合は、並べ替えられた <paramref name="span" /> 内の <paramref name="comparable" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="comparable" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.Span`1.Length" /> のビットごとの補数です。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
      <summary>指定した <typeparamref name="TComparer" /> ジェネリック型を使用し、並べ替えられた <see cref="T:System.ReadOnlySpan`1" /> 全体の中から、指定した値を検索します。</summary>
      <param name="span">検索する並べ替えられた <see cref="T:System.ReadOnlySpan`1" />。</param>
      <param name="value">検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
      <param name="comparer">比較する場合に使用する <typeparamref name="TComparer" />。</param>
      <typeparam name="T">スパンの要素の種類。</typeparam>
      <typeparam name="TComparer">の特定の型 <see cref="T:System.Collections.Generic.IComparer`1" /> 。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="value" /> が見つかった場合は、並べ替えられた <paramref name="span" /> 内の <paramref name="value" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="value" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.ReadOnlySpan`1.Length" /> のビットごとの補数です。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
      <summary>指定した <typeparamref name="TComparable" /> ジェネリック型を使用し、並べ替えられた <see cref="T:System.ReadOnlySpan`1" /> 全体の中から値を検索します。</summary>
      <param name="span">検索する並べ替えられた <see cref="T:System.ReadOnlySpan`1" />。</param>
      <param name="comparable">比較する場合に使用する <typeparamref name="TComparable" />。</param>
      <typeparam name="T">スパンの要素の種類。</typeparam>
      <typeparam name="TComparable">の特定の型 <see cref="T:System.IComparable`1" /> 。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="comparable" /> が見つかった場合は、並べ替えられた <paramref name="span" /> 内の <paramref name="comparable" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="comparable" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.ReadOnlySpan`1.Length" /> のビットごとの補数です。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
      <summary>指定した <typeparamref name="TComparer" /> ジェネリック型を使用し、並べ替えられた <see cref="T:System.Span`1" /> 全体の中から、指定した値を検索します。</summary>
      <param name="span">検索する並べ替えられた <see cref="T:System.Span`1" />。</param>
      <param name="value">検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
      <param name="comparer">比較する場合に使用する <typeparamref name="TComparer" />。</param>
      <typeparam name="T">スパンの要素の種類。</typeparam>
      <typeparam name="TComparer">の特定の型 <see cref="T:System.Collections.Generic.IComparer`1" /> 。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="value" /> が見つかった場合は、並べ替えられた <paramref name="span" /> 内の <paramref name="value" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="value" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.Span`1.Length" /> のビットごとの補数です。</returns>
    </member>
    <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
      <summary>指定した <typeparamref name="TComparable" /> ジェネリック型を使用し、並べ替えられた <see cref="T:System.Span`1" /> 全体の中から値を検索します。</summary>
      <param name="span">検索する並べ替えられた <see cref="T:System.Span`1" />。</param>
      <param name="comparable">比較する場合に使用する <typeparamref name="TComparable" />。</param>
      <typeparam name="T">スパンの要素の種類。</typeparam>
      <typeparam name="TComparable">の特定の型 <see cref="T:System.IComparable`1" /> 。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparable" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="comparable" /> が見つかった場合は、並べ替えられた <paramref name="span" /> 内の <paramref name="comparable" /> の 0 から始まるインデックス。見つからなかった場合は、負の値。これは、<paramref name="comparable" /> の次に大きい要素のインデックスのビットごとの補数です。ただし、大きい要素が存在しない場合は、<see cref="P:System.Span`1.Length" /> のビットごとの補数です。</returns>
    </member>
    <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定した文字列比較を使用して 1 つの文字スパンを別の文字スパンと比較し、並べ替え順序でそれらの相対位置を示す整数を返します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="other">ソース スパンと比較する値。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="other" /> の比較方法を決定する列挙型の値。</param>
      <returns>
        <paramref name="span" /> と <paramref name="other" /> の相対順序を示す符号付き整数。   - 0 未満の場合、<paramref name="span" /> は <paramref name="other" /> より順序が先になります。   - 0 の場合、<paramref name="span" /> は <paramref name="other" /> と等しくなります。   - 0 より大きい場合、<paramref name="span" /> は <paramref name="other" /> の後になります。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定された値が読み取り専用の文字スパン内にあるかどうかを示します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパン内でシークする値。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="value" /> 内の文字の比較方法を決定する列挙型の値。</param>
      <returns>
        <paramref name="value" /> がスパン内にある場合は <see langword="true" />。ない場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
      <summary>指定した値が読み取り専用スパンに存在するかどうかを示します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索する値。</param>
      <typeparam name="T">スパンの種類。</typeparam>
      <returns>見つかった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
      <summary>指定した値がスパンに存在するかどうかを示します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索する値。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>見つかった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
      <summary>配列の内容をメモリ領域にコピーします。</summary>
      <param name="source">項目のコピー元となる配列。</param>
      <param name="destination">項目のコピー先となるメモリ。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArgumentException">コピー先がコピー元の配列より短いです。</exception>
    </member>
    <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
      <summary>配列の内容をスパンにコピーします。</summary>
      <param name="source">項目のコピー元となる配列。</param>
      <param name="destination">項目のコピー先のスパン。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArgumentException">デスティネーション スパンがソース配列より短いです。</exception>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定された <paramref name="comparisonType" /> オプションを使って比較した場合に、<paramref name="span" /> の末尾が指定された <paramref name="value" /> と一致するかどうかを判断します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパンの末尾と比較するシーケンス。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="value" /> の比較方法を決定する列挙型の値。</param>
      <returns>
        <paramref name="value" /> が <paramref name="span" /> の末尾と一致する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>指定されたシーケンスが読み取り専用スパンの末尾にあるかどうかを判断します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパンの末尾と比較するシーケンス。</param>
      <typeparam name="T">スパンの種類。</typeparam>
      <returns>
        <paramref name="value" /> が <paramref name="span" /> の末尾と一致する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>指定されたシーケンスがスパンの末尾にあるかどうかを判断します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパンの末尾と比較するシーケンス。</param>
      <typeparam name="T">スパンの種類。</typeparam>
      <returns>
        <paramref name="value" /> が <paramref name="span" /> の末尾と一致する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
      <summary>指定された読み取り専用スパンから <see cref="T:System.Text.Rune" /> の列挙型を返します。</summary>
      <param name="span">ソース スパン。</param>
      <returns>ルーン列挙子。</returns>
    </member>
    <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
      <summary>指定されたスパンから <see cref="T:System.Text.Rune" /> の列挙型を返します。</summary>
      <param name="span">ソース スパン。</param>
      <returns>ルーン列挙子。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定した <paramref name="comparisonType" /> オプションを使用して比較した場合に、この <paramref name="span" /> と指定した <paramref name="other" /> スパンで文字が同じであるかどうかを判断します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="other">ソース スパンと比較する値。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="other" /> の比較方法を決定する列挙型の値。</param>
      <returns>等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定した <paramref name="value" /> が現在の <paramref name="span" /> 内で最初に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパン内でシークする値。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="value" /> の比較方法を決定する列挙型の値。</param>
      <returns>スパン内で値が出現する位置のインデックス。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>指定した値を検索し、それが最初に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索する値。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>指定したシーケンスを検索し、それが最初に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索対象のシーケンス。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
      <summary>指定した値を検索し、それが最初に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索する値。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>指定したシーケンスを検索し、それが最初に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索対象のシーケンス。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>論理 OR 演算子を使用して IndexOf を数回呼び出すのと同様に、指定されたいずれかの値の最初のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が出現する最初の位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>論理 OR 演算子を使用して IndexOf を数回呼び出すのと同様に、指定されたいずれかの値の最初のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <param name="value2">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が出現する最初の位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>論理 OR 演算子を使用して IndexOf を数回呼び出すのと同様に、指定されたいずれかの値の最初のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="values">検索対象の値のセット。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が出現する最初の位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>論理 OR 演算子を使用して IndexOf を数回呼び出すのと同様に、指定されたいずれかの値の最初のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が出現する最初の位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>論理 OR 演算子を使用して IndexOf を数回呼び出すのと同様に、指定されたいずれかの値の最初のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <param name="value2">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が出現する最初の位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>論理 OR 演算子を使用して IndexOf を数回呼び出すのと同様に、指定されたいずれかの値の最初のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="values">検索対象の値のセット。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が出現する最初の位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
      <summary>指定したスパンに空白文字のみが含まれているかどうかを示します。</summary>
      <param name="span">ソース スパン。</param>
      <returns>スパンに空白文字のみが含まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定した <paramref name="value" /> が現在の <paramref name="span" /> 内で最後に見つかった位置の 0 から始まるインデックスをレポートします。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパン内でシークする値。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="value" /> の比較方法を決定する列挙型の値。</param>
      <returns>スパン内で値が最後に出現する位置のインデックス。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
      <summary>指定した値を検索し、それが最後に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索する値。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>指定したシーケンスを検索し、それが最後に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索対象のシーケンス。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
      <summary>指定した値を検索し、それが最後に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索する値。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>指定したシーケンスを検索し、それが最後に見つかった位置のインデックスを返します。 値は IEquatable{T}.Equals(T) を使用して比較されます。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">検索対象のシーケンス。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内で値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
      <summary>論理 OR 演算子で LastIndexOf を数回呼び出すのと同様に、指定された値のいずれかの最後のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
      <summary>論理 OR 演算子で LastIndexOf を数回呼び出すのと同様に、指定された値のいずれかの最後のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <param name="value2">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>論理 OR 演算子で LastIndexOf を数回呼び出すのと同様に、指定された値のいずれかの最後のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="values">検索対象の値のセット。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
      <summary>論理 OR 演算子で LastIndexOf を数回呼び出すのと同様に、指定された値のいずれかの最後のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
      <summary>論理 OR 演算子で LastIndexOf を数回呼び出すのと同様に、指定された値のいずれかの最後のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value0">検索対象の値の 1 つ。</param>
      <param name="value1">検索対象の値の 1 つ。</param>
      <param name="value2">検索対象の値の 1 つ。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>論理 OR 演算子で LastIndexOf を数回呼び出すのと同様に、指定された値のいずれかの最後のインデックスを検索します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="values">検索対象の値のセット。</param>
      <typeparam name="T">スパンと値の型。</typeparam>
      <returns>スパン内でいずれかの値が最後に出現する位置のインデックス。 見つからない場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>2 つの読み取り専用シーケンスがメモリ内で重なり合うかどうかを判断します。</summary>
      <param name="span">最初のシーケンス。</param>
      <param name="other">2 番目のシーケンス。</param>
      <typeparam name="T">読み取り専用シーケンス内の要素の型。</typeparam>
      <returns>2 つのシーケンスが重なり合う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>2 つの読み取り専用シーケンスがメモリ内で重なり合うかどうかを判断し、要素のオフセットを出力します。</summary>
      <param name="span">最初のシーケンス。</param>
      <param name="other">2 番目のシーケンス。</param>
      <param name="elementOffset">メソッドが戻ると、<paramref name="span" /> と <paramref name="other" /> の間にオフセットが含まれます。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>2 つのシーケンスが重なり合う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>スパンと読み取り専用スパンがメモリ内で重なり合うかどうかを判断します。</summary>
      <param name="span">比較対象とするスパン。</param>
      <param name="other">比較する読み取り専用スパン。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>2 つのシーケンスが重なり合う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
      <summary>スパンと読み取り専用スパンがメモリ内で重なり合うかどうかを判断し、要素のオフセットを出力します。</summary>
      <param name="span">比較する最初のシーケンス。</param>
      <param name="other">比較する 2 番目のシーケンス。</param>
      <param name="elementOffset">メソッドが戻ると、<paramref name="span" /> と <paramref name="other" /> の間にオフセットが含まれます。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>2 つのシーケンスが重なり合う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
      <summary>スパン全体の要素のシーケンスを反転させます。</summary>
      <param name="span">反転対象とするスパン。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>IComparable{T}.CompareTo(T) を使用して要素を比較することで、2 つの読み取り専用シーケンスの相対順序を決定します。</summary>
      <param name="span">比較する最初のシーケンス。</param>
      <param name="other">比較する 2 番目のシーケンス。</param>
      <typeparam name="T">シーケンス内の要素の型。</typeparam>
      <returns>
        <paramref name="span" /> と <paramref name="other" /> の相対順序を示す符号付き整数。   - 0 未満の場合、<paramref name="span" /> は <paramref name="other" /> より順序が先になります。   - 0 の場合、<paramref name="span" /> は <paramref name="other" /> と等しくなります。   - 0 より大きい場合、<paramref name="span" /> は <paramref name="other" /> の後になります。</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>IComparable{T}.CompareTo(T) を使用して要素を比較することで、スパンと読み取り専用スパンの相対順序を決定します。</summary>
      <param name="span">比較対象とするスパン。</param>
      <param name="other">比較する読み取り専用スパン。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>
        <paramref name="span" /> と <paramref name="other" /> の相対順序を示す符号付き整数。   - 0 未満の場合、<paramref name="span" /> は <paramref name="other" /> より順序が先になります。   - 0 の場合、<paramref name="span" /> は <paramref name="other" /> と等しくなります。   - 0 より大きい場合、<paramref name="span" /> は <paramref name="other" /> の後になります。</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>IEquatable{T}.Equals(T) を使用して要素を比較することで、2 つの読み取り専用シーケンスが等しいかどうかを判断します。</summary>
      <param name="span">比較する最初のシーケンス。</param>
      <param name="other">比較する 2 番目のシーケンス。</param>
      <typeparam name="T">シーケンス内の要素の型。</typeparam>
      <returns>2 つのシーケンスが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>IEquatable{T}.Equals(T) を使用して要素を比較することで、スパンと読み取り専用スパンが等しいかどうかを判断します。</summary>
      <param name="span">比較対象とするスパン。</param>
      <param name="other">比較する読み取り専用スパン。</param>
      <typeparam name="T">シーケンス内の要素の型。</typeparam>
      <returns>2 つのシーケンスが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0})">
      <summary>
        <see cref="T:System.Span`1" /> の各要素の <see cref="T:System.IComparable`1" /> 実装を使用して、<see cref="T:System.Span`1" /> の全体の要素を並べ替えます。</summary>
      <param name="span">並べ替えるメモリのスパン。</param>
      <typeparam name="T">スパンの要素の型。</typeparam>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="span" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> インターフェイスを実装していません。</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})">
      <summary>指定した <see cref="T:System.Comparison`1" /> を使用して、<see cref="T:System.Span`1" /> 全体内の要素を並べ替えます。</summary>
      <param name="span">並べ替えるメモリのスパン。</param>
      <param name="comparison">要素を比較する場合に使用するメソッド。</param>
      <typeparam name="T">スパンの要素の型。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> が <see langword="null" />です。</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)">
      <summary>
        <typeparamref name="TComparer" /> を使用して、<see cref="T:System.Span`1" /> 全体の要素を並べ替えます。</summary>
      <param name="span">並べ替えるメモリのスパン。</param>
      <param name="comparer">要素を比較する場合に使用するメソッド。または、各要素の <see cref="T:System.IComparable`1" /> インターフェイスの実装を使用する場合は <see langword="null" />。</param>
      <typeparam name="T">スパンの要素の型。</typeparam>
      <typeparam name="TComparer">要素の比較に使用する比較子の型。</typeparam>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="span" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable`1" /> インターフェイスが実装されていません。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})">
      <summary>スパンのペア (一方がキーを格納し、他方がそれらに対応する項目を格納する) を、最初の <see cref="T:System.Span`1" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> を使用して並べ替えます。</summary>
      <param name="keys">並べ替え対象のキーを格納するスパン。</param>
      <param name="items">
        <paramref name="keys" /> のキーに対応する項目を格納するスパン。</param>
      <typeparam name="TKey">キースパンの要素の型。</typeparam>
      <typeparam name="TValue">項目の範囲の要素の型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="keys" /> の長さが <paramref name="items" /> の長さと一致しません。</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="keys" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> インターフェイスを実装していません。</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})">
      <summary>スパンのペア (一方がキーを格納し、他方がそれらに対応する項目を格納する) を、最初の <see cref="T:System.Span`1" /> 内のキーに基づき、指定した比較を使用して並べ替えます。</summary>
      <param name="keys">並べ替え対象のキーを格納するスパン。</param>
      <param name="items">
        <paramref name="keys" /> のキーに対応する項目を格納するスパン。</param>
      <param name="comparison">要素を比較する場合に使用する <see cref="T:System.Comparison`1" />。</param>
      <typeparam name="TKey">キースパンの要素の型。</typeparam>
      <typeparam name="TValue">項目の範囲の要素の型。</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> が <see langword="null" />です。</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keys" /> の長さが <paramref name="items" /> の長さと一致しません。</exception>
    </member>
    <member name="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)">
      <summary>スパンのペア (一方がキーを格納し、他方がそれらに対応する項目を格納する) を、最初の <see cref="T:System.Span`1" /> 内のキーに基づき、指定した比較子を使用して並べ替えます。</summary>
      <param name="keys">並べ替え対象のキーを格納するスパン。</param>
      <param name="items">
        <paramref name="keys" /> のキーに対応する項目を格納するスパン。</param>
      <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。各要素が実装する <see cref="T:System.IComparable`1" /> インターフェイスを使用する場合は <see langword="null" />。</param>
      <typeparam name="TKey">キースパンの要素の型。</typeparam>
      <typeparam name="TValue">項目の範囲の要素の型。</typeparam>
      <typeparam name="TComparer">要素の比較に使用する比較子の型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="keys" /> の長さが <paramref name="items" /> の長さと一致しません。</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="keys" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable`1" /> インターフェイスが実装されていません。</exception>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
      <summary>指定された <see cref="T:System.StringComparison" /> 値を使用して比較したときに、読み取り専用の文字スパンが指定された値で始まるかどうかを判断します。</summary>
      <param name="span">ソース スパン。</param>
      <param name="value">ソース スパンの先頭と比較するシーケンス。</param>
      <param name="comparisonType">
        <paramref name="span" /> と <paramref name="value" /> の比較方法を決定する列挙型の値。</param>
      <returns>
        <paramref name="value" /> が <paramref name="span" /> の先頭と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>指定されたシーケンスが読み取り専用スパンの先頭にあるかどうかを判断します。</summary>
      <param name="span">検索する読み取り専用の文字スパン。</param>
      <param name="value">
        <paramref name="span" /> の先頭で検索するシーケンス。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>
        <paramref name="value" /> が <paramref name="span" /> の先頭と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>指定されたシーケンスがスパンの先頭にあるかどうかを判断します。</summary>
      <param name="span">検索するスパン。</param>
      <param name="value">
        <paramref name="span" /> の先頭で検索するシーケンス。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>
        <paramref name="value" /> が <paramref name="span" /> の先頭と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>ソース スパンからデスティネーションに文字をコピーし、指定されたカルチャの大文字と小文字の規則を使用して各文字を小文字に変換します。</summary>
      <param name="source">ソース スパン。</param>
      <param name="destination">変換された文字を格納しているデスティネーション スパン。</param>
      <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
      <exception cref="T:System.InvalidOperationException">コピー元とコピー先のバッファーが重なり合います。</exception>
      <returns>デスティネーション スパンに書き込まれた文字数。 コピー先が小さすぎる場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>ソース スパンからデスティネーションに文字をコピーし、インバリアント カルチャの大文字と小文字の規則を使用して各文字を小文字に変換します。</summary>
      <param name="source">ソース スパン。</param>
      <param name="destination">変換された文字を格納しているデスティネーション スパン。</param>
      <exception cref="T:System.InvalidOperationException">コピー元とコピー先のバッファーが重なり合います。</exception>
      <returns>デスティネーション スパンに書き込まれた文字数。 コピー先が小さすぎる場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
      <summary>ソース スパンからデスティネーションに文字をコピーし、指定されたカルチャの大文字と小文字の規則を使用して各文字を大文字に変換します。</summary>
      <param name="source">ソース スパン。</param>
      <param name="destination">変換された文字を格納しているデスティネーション スパン。</param>
      <param name="culture">カルチャ固有の大文字と小文字の規則を提供するオブジェクト。</param>
      <exception cref="T:System.InvalidOperationException">コピー元とコピー先のバッファーが重なり合います。</exception>
      <returns>デスティネーション スパンに書き込まれた文字数。 コピー先が小さすぎる場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
      <summary>ソース スパンからデスティネーションに文字をコピーし、インバリアント カルチャの大文字と小文字の規則を使用して各文字を大文字に変換します。</summary>
      <param name="source">ソース スパン。</param>
      <param name="destination">変換された文字を格納しているデスティネーション スパン。</param>
      <exception cref="T:System.InvalidOperationException">コピー元とコピー先のバッファーが重なり合います。</exception>
      <returns>デスティネーション スパンに書き込まれた文字数。 コピー先が小さすぎる場合は、-1 を返します。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
      <summary>ある文字メモリ領域から先頭と末尾にある空白文字をすべて削除します。</summary>
      <param name="memory">文字が削除されるソース メモリ。</param>
      <returns>トリミングされた文字メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
      <summary>ある読み取り専用文字メモリ領域から先頭と末尾にある空白文字をすべて削除します。</summary>
      <param name="memory">文字が削除されるソース メモリ。</param>
      <returns>トリミングされた文字メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
      <summary>ある読み取り専用文字スパンから先頭と末尾にある空白文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>読み取り専用文字スパンから、先頭と末尾の現れる指定文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <param name="trimChar">検索と削除の対象となる指定された文字。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>読み取り専用文字スパンから、読み取り専用スパンに指定された文字セットが先頭と末尾に現れる箇所をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <param name="trimChars">削除対象の文字のセットを格納するスパン。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
      <summary>ある文字スパンから先頭と末尾にある空白文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <returns>トリミングされた文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
      <summary>指定された要素が先頭と末尾に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされたメモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭と末尾に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされたメモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
      <summary>指定された要素が先頭と末尾に現れる箇所をすべて、読み取り専用メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">読み取り専用メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭と末尾に現れる箇所をすべて、読み取り専用メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">読み取り専用メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
      <summary>指定された要素が先頭と末尾に現れる箇所をすべて、読み取り専用スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">読み取り専用スパン内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭と末尾に現れる箇所をすべて、読み取り専用スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">読み取り専用スパン内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
      <summary>指定された要素が先頭と末尾に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>トリミングされたスパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭と末尾に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>トリミングされたスパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
      <summary>文字メモリ領域から末尾の空白文字をすべて削除します。</summary>
      <param name="memory">文字が削除されるソース メモリ。</param>
      <returns>トリミングされた文字メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
      <summary>読み取り専用文字メモリ領域から末尾の空白文字をすべて削除します。</summary>
      <param name="memory">文字が削除されるソース メモリ。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
      <summary>読み取り専用文字スパンから末尾の空白文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>読み取り専用スパンから、指定した文字が末尾に現れる箇所をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <param name="trimChar">検索と削除の対象となる指定された文字。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>読み取り専用文字スパンから、読み取り専用スパンに指定された文字セットが末尾に現れる箇所をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <param name="trimChars">削除対象の文字のセットを格納するスパン。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
      <summary>文字スパンから末尾の空白文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <returns>トリミングされた文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
      <summary>指定された要素が末尾に現れる箇所をすべて、文字メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされたメモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が末尾に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされたメモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
      <summary>指定された要素が末尾に現れる箇所をすべて、読み取り専用メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">読み取り専用メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が末尾に現れる箇所をすべて、読み取り専用メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">読み取り専用メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
      <summary>読み取り専用スパンから、指定した要素が末尾に現れる箇所をすべて削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">読み取り専用スパン内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が末尾に現れる箇所をすべて、読み取り専用スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">読み取り専用スパン内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
      <summary>指定された要素が末尾に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>トリミングされたスパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が末尾に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>トリミングされたスパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
      <summary>あるメモリ領域から先頭にある空白文字をすべて削除します。</summary>
      <param name="memory">文字が削除されるソース メモリ。</param>
      <returns>トリミングされた文字メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
      <summary>ある読み取り専用メモリ領域から先頭にある空白文字をすべて削除します。</summary>
      <param name="memory">文字が削除されるソース メモリ。</param>
      <returns>トリミングされた読み取り専用文字メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
      <summary>ある読み取り専用スパンから先頭にある空白文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
      <summary>指定した文字が先頭に現れる箇所をすべてスパンから削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <param name="trimChar">検索と削除の対象となる指定された文字。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
      <summary>読み取り専用スパンに指定されている文字のセットが先頭に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <param name="trimChars">削除対象の文字のセットを格納するスパン。</param>
      <returns>トリミングされた読み取り専用文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
      <summary>あるスパンから先頭にある空白文字をすべて削除します。</summary>
      <param name="span">文字が削除されるソース スパン。</param>
      <returns>トリミングされた文字スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
      <summary>指定された要素が先頭に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ領域。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされたメモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされたメモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
      <summary>指定された要素が先頭に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">読み取り専用メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭に現れる箇所をすべて、メモリ領域から削除します。</summary>
      <param name="memory">要素が削除されるソース メモリ。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">読み取り専用メモリ領域内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用メモリ領域。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
      <summary>指定した要素が先頭に現れる箇所をすべてスパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">読み取り専用スパン内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">読み取り専用スパン内の要素の型。</typeparam>
      <returns>トリミングされた読み取り専用スパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
      <summary>指定した要素が先頭に現れる箇所をすべてスパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElement">検索と削除の対象となる指定の要素。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>トリミングされたスパン。</returns>
    </member>
    <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
      <summary>読み取り専用スパンで指定された一連の要素が先頭に現れる箇所をすべて、スパンから削除します。</summary>
      <param name="span">要素が削除されるソース スパン。</param>
      <param name="trimElements">削除する要素のセットを含むスパン。</param>
      <typeparam name="T">スパン内の要素の型。</typeparam>
      <returns>トリミングされたスパン。</returns>
    </member>
    <member name="T:System.Runtime.InteropServices.MemoryMarshal">
      <summary>
        <see cref="T:System.Memory`1" />、<see cref="T:System.ReadOnlyMemory`1" />、<see cref="T:System.Span`1" />、<see cref="T:System.ReadOnlySpan`1" /> と相互運用するメソッドを提供します。</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
      <summary>1 つのプリミティブ型 (<paramref name="T" />) の <see cref="T:System.ReadOnlySpan`1" /> を、<see langword="ReadOnlySpan&lt;Byte&gt;" /> にキャストします。</summary>
      <param name="span">変換するソース スライス。</param>
      <typeparam name="T">読み取り専用スパン内の項目の種類。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> には参照またはポインターが含まれています。</exception>
      <exception cref="T:System.OverflowException">新しい <see cref="T:System.ReadOnlySpan`1" /> の <see cref="P:System.ReadOnlySpan`1.Length" /> プロパティは <see cref="F:System.Int32.MaxValue" /> を超えます</exception>
      <returns>
        <see cref="T:System.Byte" /> 型の読み取り専用スパン。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
      <summary>1 つのプリミティブ型 (<paramref name="T" />) の <see cref="T:System.Span`1" /> を、<see langword="Span&lt;Byte&gt;" /> にキャストします。</summary>
      <param name="span">変換するソース スライス。</param>
      <typeparam name="T">スパン内の項目の種類。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> には参照またはポインターが含まれています。</exception>
      <exception cref="T:System.OverflowException">新しい <see cref="T:System.Span`1" /> の <see cref="P:System.Span`1.Length" /> プロパティは <see cref="F:System.Int32.MaxValue" /> を超えます</exception>
      <returns>
        <see cref="T:System.Byte" /> 型のスパン。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
      <summary>
        <see cref="T:System.ReadOnlyMemory`1" /> から <see cref="T:System.Memory`1" /> インスタンスを作成します。</summary>
      <param name="memory">読み取り専用メモリ バッファー。</param>
      <typeparam name="T">読み取り専用メモリバッファー内の項目の型。</typeparam>
      <returns>
        <see cref="T:System.ReadOnlyMemory`1" /> と同じメモリを表すメモリ ブロック。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
      <summary>読み取り専用スパンのバイトを、<paramref name="T" /> 型の構造体への読み取り専用参照として再解釈します。</summary>
      <param name="span">再解釈する読み取り専用スパン。</param>
      <typeparam name="T">返された参照の型。</typeparam>
      <returns>
        <paramref name="T" /> 型の構造体への読み取り専用参照。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
      <summary>スパンのバイトを、<paramref name="T" /> 型の構造体への参照として再解釈します。</summary>
      <param name="span">再解釈するスパン。</param>
      <typeparam name="T">返された参照の型。</typeparam>
      <returns>
        <paramref name="T" /> 型の構造体への参照。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
      <summary>1 つのプリミティブ型の読み取り専用スパンを、別のプリミティブ型の読み取り専用スパンにキャストします。</summary>
      <param name="span">変換するソース スライス。</param>
      <typeparam name="TFrom">ソーススパンの種類。</typeparam>
      <typeparam name="TTo">ターゲットスパンの種類。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> または <paramref name="TTo" /> には参照またはポインターが含まれています。</exception>
      <returns>変換された読み取り専用スパン。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
      <summary>1 つのプリミティブ型のスパンを、別のプリミティブ型のスパンにキャストします。</summary>
      <param name="span">変換するソース スライス。</param>
      <typeparam name="TFrom">ソーススパンの種類。</typeparam>
      <typeparam name="TTo">ターゲットスパンの種類。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="TFrom" /> または <paramref name="TTo" /> には参照またはポインターが含まれています。</exception>
      <returns>変換されたスパン。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
      <summary>
        <paramref name="start" /> インデックスで始まり <paramref name="length" /> 個の項目で構成される、事前にピン留めされたターゲット配列の一部に対する、新しいメモリ バッファーを作成します。</summary>
      <param name="array">事前にピン留めされたソース配列。</param>
      <param name="start">メモリ ブロックの開始位置を示す <paramref name="array" /> のインデックス。</param>
      <param name="length">メモリ ブロックに含める項目の数。</param>
      <typeparam name="T">配列の型。</typeparam>
      <exception cref="T:System.ArrayTypeMismatchException">
        <paramref name="array" /> は共変であり、<paramref name="array" /> の型は <paramref name="T[]" /> とまったく同じではありません。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> または終了インデックスは、0 から <see cref="P:System.Array.Length" /> までの範囲に含まれません。</exception>
      <returns>指定した <paramref name="array" /> の要素に対するメモリのブロック。 <paramref name="array" /> が <see langword="null" /> の場合、または <paramref name="start" /> と <paramref name="length" /> が 0 である場合、メソッドは <see cref="P:System.Memory`1.Length" /> 0 のインスタンス <see cref="T:System.Memory`1" /> を返します。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
      <summary>定期的なマネージド オブジェクトの一部に対する新しい読み取り専用スパンを作成します。</summary>
      <param name="reference">データへの参照。</param>
      <param name="length">
        <paramref name="reference" /> に含まれる <paramref name="T" /> 要素の数。</param>
      <typeparam name="T">データ項目の型。</typeparam>
      <returns>読み取り専用スパン。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
      <summary>定期的なマネージド オブジェクトの一部に対する新しいスパンを作成します。</summary>
      <param name="reference">データへの参照。</param>
      <param name="length">
        <paramref name="reference" /> に含まれる <paramref name="T" /> 要素の数。</param>
      <typeparam name="T">データ項目の型。</typeparam>
      <returns>スパン。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference``1(``0[])">
      <summary>
        <paramref name="array" /> のゼロ番目の要素への参照を返します。 配列が空の場合、ゼロ番目の要素が格納される場所への参照を返します。 そのような参照はピン留めに使用できますが、逆参照が禁止されます。</summary>
      <param name="array">分析する配列。</param>
      <typeparam name="T">配列要素の型。</typeparam>
      <exception cref="T:System.NullReferenceException">
        <paramref name="array" /> が <see langword="null" />です。</exception>
      <returns>
        <paramref name="array" /> のゼロ番目の要素への参照</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
      <summary>インデックス 0 にある読み取り専用スパンの要素の参照を返します。</summary>
      <param name="span">参照の取得元となる読み取り専用スパン。</param>
      <typeparam name="T">スパン内の項目の種類。</typeparam>
      <returns>インデックス 0 にある要素の参照。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
      <summary>インデックス 0 にあるスパンの要素の参照を返します。</summary>
      <param name="span">参照の取得元となるスパン。</param>
      <typeparam name="T">スパン内の項目の種類。</typeparam>
      <returns>インデックス 0 にある要素の参照。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
      <summary>型の構造体を読み取ります <param name="T" /> バイト型の読み取り専用スパンから。</summary>
      <param name="source">読み取り専用スパン。</param>
      <typeparam name="T">読み取り専用スパンから取得する項目の型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> には参照またはポインターが含まれています。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="source" /> が <paramref name="T" /> より小さい値になっています。</exception>
      <returns>読み取り専用スパンから取得される構造体。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
      <summary>指定した読み取り専用メモリ バッファーの <see cref="T:System.Collections.Generic.IEnumerable`1" /> ビューを作成します。</summary>
      <param name="memory">読み取り専用メモリ バッファー。</param>
      <typeparam name="T">読み取り専用メモリバッファー内の項目の型。</typeparam>
      <returns>
        <paramref name="memory" /> の列挙可能なビュー。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
      <summary>基になるメモリ バッファーから配列セグメントの取得を試みます。 戻り値は、操作の成功を示します。</summary>
      <param name="memory">読み取り専用メモリ バッファー。</param>
      <param name="segment">このメソッドが戻ると、基になる読み取り専用メモリ バッファーから取得した配列セグメントが含まれています。 メソッドが失敗した場合、メソッドは既定の配列セグメントを返します。</param>
      <typeparam name="T">読み取り専用メモリバッファー内の項目の型。</typeparam>
      <returns>メソッドの呼び出しが成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
      <summary>基になる読み取り専用メモリ バッファーから <see cref="T:System.Buffers.MemoryManager`1" /> の取得を試みます。</summary>
      <param name="memory">メモリ マネージャーを取得する対象の読み取り専用メモリ バッファー。</param>
      <param name="manager">メソッドから戻るときは、<paramref name="memory" /> のマネージャー。</param>
      <typeparam name="T">読み取り専用メモリバッファー内の項目の型。</typeparam>
      <typeparam name="TManager">取得するの型 <see cref="T:System.Buffers.MemoryManager`1" /> 。</typeparam>
      <returns>メソッドがメモリ マネージャーを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
      <summary>基になる読み取り専用メモリ バッファーから、<see cref="T:System.Buffers.MemoryManager`1" />、開始インデックス、長さの取得を試みます。</summary>
      <param name="memory">メモリ マネージャーを取得する対象の読み取り専用メモリ バッファー。</param>
      <param name="manager">メソッドから戻るときは、<paramref name="memory" /> のマネージャー。</param>
      <param name="start">メソッドから戻るときは、<paramref name="memory" /> が表す <paramref name="manager" /> の先頭からのオフセット。</param>
      <param name="length">メソッドから戻るときは、<paramref name="memory" /> が表す <paramref name="manager" /> の長さ。</param>
      <typeparam name="T">読み取り専用メモリバッファー内の項目の型。</typeparam>
      <typeparam name="TManager">取得するの型 <see cref="T:System.Buffers.MemoryManager`1" /> 。</typeparam>
      <returns>メソッドが成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
      <summary>
        <see langword="System.ReadOnlyMemory&lt;Char&gt;" /> から基になる文字列の取得を試みます。</summary>
      <param name="memory">文字のブロックを含む読み取り専用メモリ。</param>
      <param name="text">メソッドが戻ると、文字列はメモリ バッファーに含まれています。</param>
      <param name="start">
        <paramref name="text" /> の開始位置。</param>
      <param name="length">
        <paramref name="text" /> の文字数。</param>
      <returns>メソッドが基になる文字列の取得に成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
      <summary>バイト型の読み取り専用スパンから <paramref name="T" /> 型の構造体の読み取りを試みます。</summary>
      <param name="source">バイト型の読み取り専用スパン。</param>
      <param name="value">メソッドから戻るときは、<paramref name="T" /> のインスタンス。</param>
      <typeparam name="T">取得する構造体の型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> には参照またはポインターが含まれています。</exception>
      <returns>メソッドが構造体のインスタンスの取得に成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
      <summary>バイト型のスパンに <paramref name="T" /> 型の構造体の書き込みを試みます。</summary>
      <param name="destination">構造体を含むバイト型のスパン。</param>
      <param name="value">スパンに書き込まれる構造体。</param>
      <typeparam name="T">構造体の型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> には参照またはポインターが含まれています。</exception>
      <returns>書き込み操作が成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <paramref name="T" /> を格納するにはスパンが小さすぎる場合、メソッドは <see langword="false" /> を返します。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
      <summary>バイト型のスパンに <paramref name="T" /> 型の構造体を書き込みます。</summary>
      <param name="destination">構造体を含むバイト型のスパン。</param>
      <param name="value">スパンに書き込まれる構造体。</param>
      <typeparam name="T">構造体の型。</typeparam>
      <exception cref="T:System.ArgumentException">
        <paramref name="T" /> には参照またはポインターが含まれています。</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destination" /> は <paramref name="value" /> を含めるには小さすぎます。</exception>
    </member>
    <member name="T:System.Runtime.InteropServices.SequenceMarshal">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> と相互運用するためのメソッドのコレクションを提供します。</summary>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
      <summary>基になる読み取り専用シーケンスから配列セグメントを取得します。</summary>
      <param name="sequence">配列セグメントの取得元となる読み取り専用のシーケンス。</param>
      <param name="segment">返された配列セグメント。</param>
      <typeparam name="T">読み取り専用シーケンスの型。</typeparam>
      <returns>配列セグメントを取得できる場合は <see langword="true" />、それ以外の場合は <see langword="false" /> で、既定の配列セグメントが返されます。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
      <summary>指定した読み取り専用シーケンスから読み取り専用メモリの取得を試みます。</summary>
      <param name="sequence">メモリの取得元となる読み取り専用のシーケンス。</param>
      <param name="memory">T 型で返された読み取り専用のメモリ。</param>
      <typeparam name="T">読み取り専用シーケンスの型。</typeparam>
      <returns>読み取り専用メモリを取得できる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
      <summary>指定した読み取り専用シーケンスから読み取り専用シーケンス セグメントの取得を試みます。</summary>
      <param name="sequence">読み取り専用シーケンス セグメントの取得元となる読み取り専用のシーケンス。</param>
      <param name="startSegment">先頭の読み取り専用シーケンス セグメント。</param>
      <param name="startIndex">最初の位置。</param>
      <param name="endSegment">末尾の読み取り専用シーケンス セグメント。</param>
      <param name="endIndex">最後の位置。</param>
      <typeparam name="T">読み取り専用シーケンスの型。</typeparam>
      <returns>読み取り専用シーケンス セグメントを取得できる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
      <summary>バッファーから指定された型の読み取りを試みます。 このメソッドを任意の構造体で使用するのは危険です。詳細については、注釈を参照してください。</summary>
      <param name="reader">シーケンス ヘッダへの参照。</param>
      <param name="value">読み取りが成功した場合は、返された値。 領域不足により失敗した場合は、<paramref name="value" /> が <see langword="default" /> になります。</param>
      <typeparam name="T">値の型。</typeparam>
      <returns>読み取りが正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="T:System.SequencePosition">
      <summary>連続していないメモリのセット内の位置を表します。 この型のプロパティは、それを作成した型以外のものでは解釈できません。</summary>
    </member>
    <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
      <summary>
        <see cref="T:System.SequencePosition" /> 構造体の新しいインスタンスを初期化します。</summary>
      <param name="object">連続していないメモリのセット。</param>
      <param name="integer">
        <paramref name="object" /> 内の位置。</param>
    </member>
    <member name="M:System.SequencePosition.Equals(System.Object)">
      <summary>現在のインスタンスが別のオブジェクトと等しいかどうかを示す値を返します。</summary>
      <param name="obj">現在のインスタンスと比較するオブジェクト。</param>
      <returns>
        <paramref name="obj" /> の型が <see cref="T:System.SequencePosition" /> で、現在のインスタンスに等しければ <see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
    </member>
    <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
      <summary>現在のインスタンスが <see cref="T:System.SequencePosition" /> と等しいかどうかを示します。</summary>
      <param name="other">現在のインスタンスと比較するシーケンス位置。</param>
      <returns>2 つのインスタンスが等しい場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
    </member>
    <member name="M:System.SequencePosition.GetHashCode">
      <summary>このインスタンスのハッシュ コードを返します。</summary>
      <returns>対象のインスタンスのハッシュ コード。</returns>
    </member>
    <member name="M:System.SequencePosition.GetInteger">
      <summary>この <see cref="T:System.SequencePosition" /> の整数部分を返します。</summary>
      <returns>このシーケンス位置の整数部分。</returns>
    </member>
    <member name="M:System.SequencePosition.GetObject">
      <summary>この <see cref="T:System.SequencePosition" /> のオブジェクト部分を返します。</summary>
      <returns>このシーケンス位置のオブジェクト部分。</returns>
    </member>
    <member name="T:System.Text.EncodingExtensions">
      <summary>
        <see cref="T:System.Text.Encoding" />、<see cref="T:System.Text.Encoder" />、<see cref="T:System.Text.Decoder" /> など、エンコードの種類の拡張メソッドを提供します。</summary>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> を UTF-16 エンコード文字に変換し、その結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="decoder">バイトを <see langword="char" /> 値に変換できるデコーダー インスタンス。</param>
      <param name="bytes">デコードするバイト シーケンス。</param>
      <param name="writer">デコードされた文字が書き込まれるバッファー。</param>
      <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <param name="charsUsed">このメソッドから戻った時点では、<paramref name="writer" /> に書き込まれた文字数が格納されています。</param>
      <param name="completed">このメソッドから戻った時点では、<paramref name="decoder" /> に部分的な内部状態が含まれていない場合は、<see langword="true" /> が含まれます。それ以外の場合は <see langword="false" /> が含まれます。
<paramref name="flush" /> が <see langword="true" /> の場合、メソッドから戻った時点で、これは常に <see langword="true" /> に設定されています。</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> にはデコードできないデータが含まれており、<paramref name="decoder" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Decoder,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>
        <paramref name="decoder" /> を使用して <see cref="T:System.ReadOnlySpan`1" /> を文字に変換し、結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="decoder">バイトを <see langword="char" /> 値に変換できるデコーダー インスタンス。</param>
      <param name="bytes">デコードするバイト シーケンス。</param>
      <param name="writer">デコードされた文字が書き込まれるバッファー。</param>
      <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <param name="charsUsed">このメソッドから戻った時点では、<paramref name="writer" /> に書き込まれた <see langword="char" /> の数が含まれます。</param>
      <param name="completed">このメソッドから戻った時点では、<paramref name="decoder" /> に部分的な内部状態が含まれていない場合は、<see langword="true" /> が含まれます。それ以外の場合は <see langword="false" /> が含まれます。
<paramref name="flush" /> が <see langword="true" /> の場合、メソッドから戻った時点で、これは常に <see langword="true" /> に設定されています。</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> にはエンコードできないデータが含まれており、<paramref name="decoder" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>
        <see cref="T:System.Buffers.ReadOnlySequence`1" /> をエンコードされたバイトに変換し、その結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="encoder">
        <see langword="char" /> 値をバイトに変換できるエンコーダー インスタンス。</param>
      <param name="chars">エンコードする文字のシーケンス。</param>
      <param name="writer">エンコードされたバイトが書き込まれるバッファー。</param>
      <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <param name="bytesUsed">このメソッドから戻った時点では、<paramref name="writer" /> に書き込まれた <see langword="byte" /> の数が含まれます。</param>
      <param name="completed">このメソッドから戻った時点では、<paramref name="bytesUsed" /> までのすべての入力が変換された場合は <see langword="true" /> が含まれます。それ以外の場合は <see langword="false" /> が含まれます。 <paramref name="flush" /> が <see langword="true" /> の場合、メソッドから戻った時点で、これは常に <see langword="true" /> に設定されています。</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> にはエンコードできないデータが含まれており、<paramref name="encoder" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.Convert(System.Text.Encoder,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Int64@,System.Boolean@)">
      <summary>
        <paramref name="encoder" /> を使用して <see cref="T:System.ReadOnlySpan`1" /> をバイトに変換し、結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="encoder">
        <see langword="char" /> 値をバイトに変換できるエンコーダー インスタンス。</param>
      <param name="chars">エンコードする文字のシーケンス。</param>
      <param name="writer">エンコードされたバイトが書き込まれるバッファー。</param>
      <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
      <param name="bytesUsed">このメソッドから戻った時点では、<paramref name="writer" /> に書き込まれた <see langword="byte" /> の数が含まれます。</param>
      <param name="completed">このメソッドから戻った時点では、<paramref name="encoder" /> に部分的な内部状態が含まれていない場合は、<see langword="true" /> が含まれます。それ以外の場合は <see langword="false" /> が含まれます。
<paramref name="flush" /> が <see langword="true" /> の場合、メソッドから戻った時点で、これは常に <see langword="true" /> に設定されています。</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> にはエンコードできないデータが含まれており、<paramref name="encoder" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@)">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して、指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> を <see cref="T:System.Byte" /> 配列にエンコードします。</summary>
      <param name="encoding">
        <paramref name="chars" /> 内のデータをエンコードする方法を表すエンコード。</param>
      <param name="chars">バイトにエンコードするシーケンス。</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> にはエンコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="chars" /> のエンコードされた内容を表す <see cref="T:System.Byte" /> 配列。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Buffers.IBufferWriter{System.Byte})">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> を <see langword="byte" /> にデコードし、結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="encoding">
        <paramref name="chars" /> 内のデータをエンコードする方法を表すエンコード。</param>
      <param name="chars">内容をエンコードする必要がある <see cref="T:System.Buffers.ReadOnlySequence`1" />。</param>
      <param name="writer">エンコードされたバイトが書き込まれるバッファー。</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> にはエンコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="writer" /> に書き込むバイト数。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Char}@,System.Span{System.Byte})">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> を <see langword="byte" /> にエンコードし、結果を <paramref name="bytes" /> に出力します。</summary>
      <param name="encoding">
        <paramref name="chars" /> 内のデータをエンコードする方法を表すエンコード。</param>
      <param name="chars">バイトにエンコードするシーケンス。</param>
      <param name="bytes">エンコードされたバイトの書き込み先のバッファー。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="bytes" /> は、<paramref name="chars" /> のエンコード形式を格納するのに十分な大きさではありません。</exception>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> にはエンコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="bytes" /> に書き込むバイト数。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},System.Buffers.IBufferWriter{System.Byte})">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して指定された <see cref="T:System.ReadOnlySpan`1" /> を <see langword="byte" /> にエンコードし、結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="encoding">
        <paramref name="chars" /> 内のデータをエンコードする方法を表すエンコード。</param>
      <param name="chars">バイトにエンコードするシーケンス。</param>
      <param name="writer">エンコードされたバイトが書き込まれるバッファー。</param>
      <exception cref="T:System.Text.EncoderFallbackException">
        <paramref name="chars" /> にはエンコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="writer" /> に書き込むバイト数。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Buffers.IBufferWriter{System.Char})">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> を <see langword="char" /> にデコードし、結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="encoding">
        <paramref name="bytes" /> 内のデータをデコードする方法を表すエンコード。</param>
      <param name="bytes">バイトをデコードする必要があるシーケンス。</param>
      <param name="writer">デコードされた文字が書き込まれるバッファー。</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> にはデコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="writer" /> に書き込まれた文字数。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Char})">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> を <see langword="char" /> にデコードし、結果を <paramref name="chars" /> に出力します。</summary>
      <param name="encoding">
        <paramref name="bytes" /> 内のデータをエンコードする方法を表すエンコード。</param>
      <param name="bytes">文字にデコードするシーケンス。</param>
      <param name="chars">デコードされた文字が書き込まれる先のバッファー。</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="chars" /> は、<paramref name="bytes" /> のエンコード形式を格納するのに十分な大きさではありません。</exception>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> にはデコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="chars" /> に書き込まれた文字数。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Char})">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して指定された <see cref="T:System.ReadOnlySpan`1" /> を <see langword="char" /> にデコードし、結果を <paramref name="writer" /> に書き込みます。</summary>
      <param name="encoding">
        <paramref name="bytes" /> 内のデータをデコードする方法を表すエンコード。</param>
      <param name="bytes">デコードするバイトの範囲。</param>
      <param name="writer">デコードされた文字が書き込まれるバッファー。</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> にはデコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="writer" /> に書き込まれた文字数。</returns>
    </member>
    <member name="M:System.Text.EncodingExtensions.GetString(System.Text.Encoding,System.Buffers.ReadOnlySequence{System.Byte}@)">
      <summary>指定された <see cref="T:System.Text.Encoding" /> を使用して、指定された <see cref="T:System.Buffers.ReadOnlySequence`1" /> を <see cref="T:System.String" /> にデコードします。</summary>
      <param name="encoding">
        <paramref name="bytes" /> 内のデータをエンコードする方法を表すエンコード。</param>
      <param name="bytes">文字にデコードするシーケンス。</param>
      <exception cref="T:System.Text.DecoderFallbackException">
        <paramref name="bytes" /> にはデコードできないデータが含まれており、<paramref name="encoding" /> はそのようなデータがあるときにスローされるように構成されています。</exception>
      <returns>
        <paramref name="bytes" /> のデコードされた内容を表す <see cref="T:System.String" />。</returns>
    </member>
    <member name="T:System.Text.SpanRuneEnumerator">
      <summary>UTF-16 テキストを含むスパンによって表される <see cref="T:System.Text.Rune" /> 値の列挙子を提供します。</summary>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.GetEnumerator">
      <summary>現在の列挙子インスタンスを返します。</summary>
      <returns>現在の列挙子インスタンス。</returns>
    </member>
    <member name="M:System.Text.SpanRuneEnumerator.MoveNext">
      <summary>列挙子をスパンの次の <see cref="T:System.Text.Rune" /> に進めます。</summary>
      <returns>列挙子が次の項目に正常に進んだ場合は <see langword="true" />。スパンの末尾に達した場合は <see langword="false" />。</returns>
    </member>
    <member name="P:System.Text.SpanRuneEnumerator.Current">
      <summary>列挙子の現在位置にある <see cref="T:System.Text.Rune" /> を取得します。</summary>
      <returns>
        <see cref="T:System.Text.Rune" />列挙子の現在位置にある。</returns>
    </member>
  </members>
</doc>